{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/daveAnalyst/zindi-mhp-energy-prediction-2025/blob/master/zindi_mhp_dev.ipynb1\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "562fd2ac",
      "metadata": {
        "id": "562fd2ac"
      },
      "source": [
        "# Zindi Micro-Hydropower Energy Load Prediction\n",
        "\n",
        "This notebook aims to predict daily energy consumption (kWh) per data user for Micro-Hydropower Plants (MHPs) in Kalam, Pakistan. We will use MHP sensor data and climate indicators to build a predictive model.\n",
        "\n",
        "**Objective:** Forecast total daily kWh per user for one month into the future.\n",
        "**Metric:** Root Mean Squared Error (RMSE)."
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "y_PALnKIZjqU",
        "outputId": "5c42cd4e-f45a-44ba-8885-48f7b70a5a07"
      },
      "id": "y_PALnKIZjqU",
      "execution_count": 1,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Mounted at /content/drive\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "!pip install -r requirements.txt\n",
        "# Or if requirements.txt is missing/outdated, install key ones:\n",
        "!pip install pandas openpyxl lightgbm matplotlib seaborn --upgrade"
      ],
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "4GzbsojfaNZi",
        "outputId": "d5afb1ef-ccd7-4810-a04a-cdbe712aabda"
      },
      "id": "4GzbsojfaNZi",
      "execution_count": 2,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[31mERROR: Could not open requirements file: [Errno 2] No such file or directory: 'requirements.txt'\u001b[0m\u001b[31m\n",
            "\u001b[0mRequirement already satisfied: pandas in /usr/local/lib/python3.11/dist-packages (2.2.2)\n",
            "Collecting pandas\n",
            "  Downloading pandas-2.2.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (89 kB)\n",
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m89.9/89.9 kB\u001b[0m \u001b[31m3.1 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hRequirement already satisfied: openpyxl in /usr/local/lib/python3.11/dist-packages (3.1.5)\n",
            "Requirement already satisfied: lightgbm in /usr/local/lib/python3.11/dist-packages (4.5.0)\n",
            "Collecting lightgbm\n",
            "  Downloading lightgbm-4.6.0-py3-none-manylinux_2_28_x86_64.whl.metadata (17 kB)\n",
            "Requirement already satisfied: matplotlib in /usr/local/lib/python3.11/dist-packages (3.10.0)\n",
            "Collecting matplotlib\n",
            "  Downloading matplotlib-3.10.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (11 kB)\n",
            "Requirement already satisfied: seaborn in /usr/local/lib/python3.11/dist-packages (0.13.2)\n",
            "Requirement already satisfied: numpy>=1.23.2 in /usr/local/lib/python3.11/dist-packages (from pandas) (2.0.2)\n",
            "Requirement already satisfied: python-dateutil>=2.8.2 in /usr/local/lib/python3.11/dist-packages (from pandas) (2.8.2)\n",
            "Requirement already satisfied: pytz>=2020.1 in /usr/local/lib/python3.11/dist-packages (from pandas) (2025.2)\n",
            "Requirement already satisfied: tzdata>=2022.7 in /usr/local/lib/python3.11/dist-packages (from pandas) (2025.2)\n",
            "Requirement already satisfied: et-xmlfile in /usr/local/lib/python3.11/dist-packages (from openpyxl) (2.0.0)\n",
            "Requirement already satisfied: scipy in /usr/local/lib/python3.11/dist-packages (from lightgbm) (1.14.1)\n",
            "Requirement already satisfied: contourpy>=1.0.1 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (1.3.1)\n",
            "Requirement already satisfied: cycler>=0.10 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (0.12.1)\n",
            "Requirement already satisfied: fonttools>=4.22.0 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (4.56.0)\n",
            "Requirement already satisfied: kiwisolver>=1.3.1 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (1.4.8)\n",
            "Requirement already satisfied: packaging>=20.0 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (24.2)\n",
            "Requirement already satisfied: pillow>=8 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (11.1.0)\n",
            "Requirement already satisfied: pyparsing>=2.3.1 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (3.2.3)\n",
            "Requirement already satisfied: six>=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil>=2.8.2->pandas) (1.17.0)\n",
            "Downloading pandas-2.2.3-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (13.1 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m13.1/13.1 MB\u001b[0m \u001b[31m54.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading lightgbm-4.6.0-py3-none-manylinux_2_28_x86_64.whl (3.6 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m3.6/3.6 MB\u001b[0m \u001b[31m62.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading matplotlib-3.10.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (8.6 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m8.6/8.6 MB\u001b[0m \u001b[31m67.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hInstalling collected packages: pandas, matplotlib, lightgbm\n",
            "  Attempting uninstall: pandas\n",
            "    Found existing installation: pandas 2.2.2\n",
            "    Uninstalling pandas-2.2.2:\n",
            "      Successfully uninstalled pandas-2.2.2\n",
            "  Attempting uninstall: matplotlib\n",
            "    Found existing installation: matplotlib 3.10.0\n",
            "    Uninstalling matplotlib-3.10.0:\n",
            "      Successfully uninstalled matplotlib-3.10.0\n",
            "  Attempting uninstall: lightgbm\n",
            "    Found existing installation: lightgbm 4.5.0\n",
            "    Uninstalling lightgbm-4.5.0:\n",
            "      Successfully uninstalled lightgbm-4.5.0\n",
            "\u001b[31mERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.\n",
            "google-colab 1.0.0 requires pandas==2.2.2, but you have pandas 2.2.3 which is incompatible.\u001b[0m\u001b[31m\n",
            "\u001b[0mSuccessfully installed lightgbm-4.6.0 matplotlib-3.10.1 pandas-2.2.3\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import os\n",
        "import zipfile\n",
        "import shutil\n",
        "\n",
        "# Define path to data on Google Drive (adjust if your folder structure differs)\n",
        "DRIVE_DATA_PATH = '/content/drive/MyDrive/Zindi MHP Challenge/data'\n",
        "\n",
        "# Define path for data within Colab's runtime storage\n",
        "COLAB_DATA_PATH = '/content/data' # This is temporary storage\n",
        "\n",
        "# Create the target directory in Colab\n",
        "os.makedirs(COLAB_DATA_PATH, exist_ok=True)\n",
        "\n",
        "print(\"Unzipping Data.zip...\")\n",
        "try:\n",
        "    with zipfile.ZipFile(os.path.join(DRIVE_DATA_PATH, 'Data.zip'), 'r') as zip_ref:\n",
        "        zip_ref.extractall(COLAB_DATA_PATH)\n",
        "    print(\"Data.zip unzipped.\")\n",
        "except FileNotFoundError:\n",
        "    print(f\"ERROR: Data.zip not found at {os.path.join(DRIVE_DATA_PATH, 'Data.zip')}\")\n",
        "\n",
        "print(\"\\nUnzipping Climate Data.zip...\")\n",
        "try:\n",
        "    # Assuming Climate Data.zip contains the .xlsx file, maybe inside a folder\n",
        "    with zipfile.ZipFile(os.path.join(DRIVE_DATA_PATH, 'Climate Data.zip'), 'r') as zip_ref:\n",
        "        zip_ref.extractall(COLAB_DATA_PATH) # Extract directly into /content/data\n",
        "    print(\"Climate Data.zip unzipped. Check contents:\")\n",
        "    !ls -R {COLAB_DATA_PATH} # List contents recursively to find the .xlsx file\n",
        "    # You might need to move the .xlsx file out of a subfolder if one was created\n",
        "    !mv \"{COLAB_DATA_PATH}/Climate Data/Kalam Climate Data.xlsx\" \"{COLAB_DATA_PATH}/\"\n",
        "\n",
        "except FileNotFoundError:\n",
        "    print(f\"ERROR: Climate Data.zip not found at {os.path.join(DRIVE_DATA_PATH, 'Climate Data.zip')}\")\n",
        "\n",
        "print(\"\\nCopying SampleSubmission.csv...\")\n",
        "try:\n",
        "    shutil.copy(os.path.join(DRIVE_DATA_PATH, 'SampleSubmission.csv'), COLAB_DATA_PATH)\n",
        "    print(\"SampleSubmission.csv copied.\")\n",
        "except FileNotFoundError:\n",
        "     print(f\"ERROR: SampleSubmission.csv not found at {os.path.join(DRIVE_DATA_PATH, 'SampleSubmission.csv')}\")\n",
        "\n",
        "print(\"\\nFinal contents of Colab data directory:\")\n",
        "!ls {COLAB_DATA_PATH}\n",
        "\n",
        "# IMPORTANT: Set DATA_DIR for the rest of the notebook to use this Colab path\n",
        "DATA_DIR_FOR_NOTEBOOK = COLAB_DATA_PATH"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "collapsed": true,
        "id": "xQUT5aaaakIL",
        "outputId": "f8cedfdd-be92-466f-8f0d-31b0077714a0"
      },
      "id": "xQUT5aaaakIL",
      "execution_count": 3,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Unzipping Data.zip...\n",
            "Data.zip unzipped.\n",
            "\n",
            "Unzipping Climate Data.zip...\n",
            "Climate Data.zip unzipped. Check contents:\n",
            "/content/data:\n",
            "'Climate Data'\t Data.csv   __MACOSX\n",
            "\n",
            "'/content/data/Climate Data':\n",
            "'Correlation Matrix.png'   'snow with MHPs.jpg'\n",
            "'Kalam Climate Data.xlsx'  'temperature with MHPs.jpg'\n",
            "\n",
            "/content/data/__MACOSX:\n",
            "\n",
            "Copying SampleSubmission.csv...\n",
            "SampleSubmission.csv copied.\n",
            "\n",
            "Final contents of Colab data directory:\n",
            "'Climate Data'\t Data.csv  'Kalam Climate Data.xlsx'   __MACOSX   SampleSubmission.csv\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 9,
      "id": "60f49b94",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "60f49b94",
        "outputId": "6a47b35a-fa70-4034-f5c5-9e3a562c2a2d"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Libraries imported and settings configured.\n",
            "Data directory set to: data\n",
            "Available plotting styles: ['Solarize_Light2', '_classic_test_patch', '_mpl-gallery', '_mpl-gallery-nogrid', 'bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'petroff10', 'seaborn-v0_8', 'seaborn-v0_8-bright', 'seaborn-v0_8-colorblind', 'seaborn-v0_8-dark', 'seaborn-v0_8-dark-palette', 'seaborn-v0_8-darkgrid', 'seaborn-v0_8-deep', 'seaborn-v0_8-muted', 'seaborn-v0_8-notebook', 'seaborn-v0_8-paper', 'seaborn-v0_8-pastel', 'seaborn-v0_8-poster', 'seaborn-v0_8-talk', 'seaborn-v0_8-ticks', 'seaborn-v0_8-white', 'seaborn-v0_8-whitegrid', 'tableau-colorblind10']\n"
          ]
        }
      ],
      "source": [
        "# Basic libraries\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import math # For sqrt\n",
        "import os\n",
        "\n",
        "# Modeling\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.metrics import mean_squared_error\n",
        "import lightgbm as lgb\n",
        "\n",
        "# Settings\n",
        "SEED = 42\n",
        "np.random.seed(SEED)\n",
        "DATA_DIR = 'data' # Set the path to your data directory\n",
        "\n",
        "# Ensure plots are displayed inline and set a style\n",
        "%matplotlib inline\n",
        "# Use a style that's likely available - adjust if needed\n",
        "plt.style.use('seaborn-v0_8-darkgrid')\n",
        "# If the above fails, try: plt.style.use('seaborn-darkgrid') or plt.style.use('ggplot')\n",
        "\n",
        "print(\"Libraries imported and settings configured.\")\n",
        "print(f\"Data directory set to: {DATA_DIR}\")\n",
        "print(f\"Available plotting styles: {plt.style.available}\") # Optional: see available styles"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import os\n",
        "\n",
        "# ---- IMPORTANT: SET THIS CORRECTLY ----\n",
        "# Option 1: If you unzipped/copied data to Colab runtime storage\n",
        "DATA_DIR = '/content/data'\n",
        "# Option 2: If you are reading directly from Google Drive (potentially slower)\n",
        "# DATA_DIR = '/content/drive/MyDrive/Zindi MHP Challenge/data' # Adjust path if needed\n",
        "# --------------------------------------\n",
        "\n",
        "print(f\"Using DATA_DIR: {DATA_DIR}\")\n",
        "\n",
        "# Check 1: Does DATA_DIR exist?\n",
        "print(f\"\\nChecking existence of DATA_DIR...\")\n",
        "if not os.path.exists(DATA_DIR):\n",
        "    print(f\"--- ERROR ---: Directory '{DATA_DIR}' does NOT exist!\")\n",
        "    print(\"Action: Ensure you have run the Drive mount AND the data unzipping/copying cell correctly in this session.\")\n",
        "else:\n",
        "    print(f\"Directory '{DATA_DIR}' exists.\")\n",
        "\n",
        "    # Check 2: List files in DATA_DIR (Check names and capitalization!)\n",
        "    print(f\"\\nFiles present in '{DATA_DIR}':\")\n",
        "    !ls -lh \"{DATA_DIR}\" # Use shell command for clear listing\n",
        "\n",
        "    # Check 3: Verify specific expected files\n",
        "    expected_files = ['Data.csv', 'Kalam Climate Data.xlsx', 'SampleSubmission.csv']\n",
        "    print(\"\\nChecking for expected files:\")\n",
        "    all_found = True\n",
        "    for f_name in expected_files:\n",
        "        f_path = os.path.join(DATA_DIR, f_name)\n",
        "        if os.path.exists(f_path):\n",
        "            print(f\"  [ OK ] Found: {f_name}\")\n",
        "        else:\n",
        "            print(f\"  [FAIL] MISSING: {f_name} at path {f_path}\")\n",
        "            all_found = False\n",
        "    if not all_found:\n",
        "        print(\"--- ERROR ---: One or more required data files are missing from DATA_DIR.\")\n",
        "        print(\"Action: Re-run the data unzipping/copying cell, checking its output for errors.\")\n",
        "    else:\n",
        "        print(\"All expected files seem to be present.\")\n",
        "\n",
        "# Check 4: Ensure openpyxl is installed (relevant for Excel)\n",
        "print(\"\\nChecking for openpyxl installation...\")\n",
        "try:\n",
        "    import openpyxl\n",
        "    print(\"  [ OK ] openpyxl is installed.\")\n",
        "except ImportError:\n",
        "    print(\"  [FAIL] openpyxl is NOT installed.\")\n",
        "    print(\"Action: Run '!pip install openpyxl' in a cell.\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "collapsed": true,
        "id": "bi7Syey5eF5a",
        "outputId": "a0689e6e-3669-4347-f40a-4548e40d4cc2"
      },
      "id": "bi7Syey5eF5a",
      "execution_count": 1,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Using DATA_DIR: /content/data\n",
            "\n",
            "Checking existence of DATA_DIR...\n",
            "Directory '/content/data' exists.\n",
            "\n",
            "Files present in '/content/data':\n",
            "total 2.8G\n",
            "drwxr-xr-x 2 root root 4.0K Apr  5 14:48 'Climate Data'\n",
            "-rw-r--r-- 1 root root 2.8G Apr  5 14:48  Data.csv\n",
            "-rw-r--r-- 1 root root 735K Apr  5 14:48 'Kalam Climate Data.xlsx'\n",
            "drwxr-xr-x 2 root root 4.0K Apr  5 14:48  __MACOSX\n",
            "-rw------- 1 root root 260K Apr  5 14:48  SampleSubmission.csv\n",
            "\n",
            "Checking for expected files:\n",
            "  [ OK ] Found: Data.csv\n",
            "  [ OK ] Found: Kalam Climate Data.xlsx\n",
            "  [ OK ] Found: SampleSubmission.csv\n",
            "All expected files seem to be present.\n",
            "\n",
            "Checking for openpyxl installation...\n",
            "  [ OK ] openpyxl is installed.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import pandas as pd\n",
        "import os\n",
        "\n",
        "# --- Use the SAME DATA_DIR as verified in Step 1 ---\n",
        "DATA_DIR = '/content/data' # Or your Drive path\n",
        "# ----------------------------------------------------\n",
        "\n",
        "print(\"--- Verifying Column Names ---\")\n",
        "\n",
        "# Check CSV Columns\n",
        "try:\n",
        "    print(\"\\nChecking Data.csv headers...\")\n",
        "    csv_path = os.path.join(DATA_DIR, 'Data.csv')\n",
        "    # Load only 5 rows, use engine='python' if C engine failed before\n",
        "    csv_head = pd.read_csv(csv_path, nrows=5, engine='python')\n",
        "    print(f\"Columns found in Data.csv: {csv_head.columns.tolist()}\")\n",
        "    # --->>> CONFIRM: Are 'date_time' and 'Source' exactly as expected? <<<---\n",
        "except Exception as e:\n",
        "    print(f\"ERROR reading Data.csv header: {e}\")\n",
        "\n",
        "# Check Excel Columns\n",
        "try:\n",
        "    print(\"\\nChecking Kalam Climate Data.xlsx headers...\")\n",
        "    excel_path = os.path.join(DATA_DIR, 'Kalam Climate Data.xlsx')\n",
        "    excel_head = pd.read_excel(excel_path, nrows=5) # Reads first sheet by default\n",
        "    print(f\"Columns found in Kalam Climate Data.xlsx: {excel_head.columns.tolist()}\")\n",
        "    # --->>> CONFIRM: Is 'Date_Time' exactly as expected? <<<---\n",
        "    # Let's also see the format of the date column\n",
        "    date_col_name = 'Date_Time' # Use the actual column name found\n",
        "    if date_col_name in excel_head.columns:\n",
        "         print(f\"Sample values in Excel column '{date_col_name}':\")\n",
        "         print(excel_head[date_col_name].head())\n",
        "    else:\n",
        "         print(f\"Warning: Column '{date_col_name}' not found in Excel header check.\")\n",
        "\n",
        "except Exception as e:\n",
        "    print(f\"ERROR reading Kalam Climate Data.xlsx header: {e}\")"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "collapsed": true,
        "id": "hOcFuzH1ebLQ",
        "outputId": "4ea268bd-f10d-49ef-921d-1813ef28848d"
      },
      "id": "hOcFuzH1ebLQ",
      "execution_count": 2,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "--- Verifying Column Names ---\n",
            "\n",
            "Checking Data.csv headers...\n",
            "Columns found in Data.csv: ['date_time', 'v_red', 'current', 'power_factor', 'kwh', 'Source', 'v_blue', 'v_yellow', 'consumer_device_9', 'consumer_device_x']\n",
            "\n",
            "Checking Kalam Climate Data.xlsx headers...\n",
            "Columns found in Kalam Climate Data.xlsx: ['Date Time', 'Temperature (°C)', 'Dewpoint Temperature (°C)', 'U Wind Component (m/s)', 'V Wind Component (m/s)', 'Total Precipitation (mm)', 'Snowfall (mm)', 'Snow Cover (%)']\n",
            "Warning: Column 'Date_Time' not found in Excel header check.\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c02b6671",
      "metadata": {
        "id": "c02b6671"
      },
      "source": [
        "## 2. Load Data\n",
        "\n",
        "Load the datasets:\n",
        "1.  **MHP Data:** `Data.csv` contains the 5-minute interval sensor readings (voltage, current, kWh, etc.). We anticipate the timestamp column is named `date_time`.\n",
        "2.  **Climate Data:** `Kalam Climate Data.xlsx` contains climate indicators (temperature, precipitation, etc.). This is an Excel file.\n",
        "3.  **Sample Submission:** `SampleSubmission.csv` defines the required prediction format and IDs for the test set.\n",
        "\n",
        "*Note: Reading Excel files requires the `openpyxl` library. Install it if needed (`pip install openpyxl`). Reading the MHP CSV might require `engine='python'` if the default C engine fails.*"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "id": "46194803",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "collapsed": true,
        "id": "46194803",
        "outputId": "e7f39d87-773f-4211-c217-6d013a932e67"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Loading data with verified column names...\n",
            "\n",
            "[0.0s] Attempting to load MHP structure from: /content/data/Data.csv\n",
            "Loading only columns: ['date_time', 'Source', 'kwh']\n",
            "[66.5s] Structure loaded for Data.csv. Size: (39147559, 3)\n",
            "[66.5s] Converting MHP date column ('date_time')...\n",
            "[81.7s] MHP date converted.\n",
            "[81.7s] Loaded and initially processed: Data.csv\n",
            "\n",
            "[81.7s] Attempting to load Excel structure from: /content/data/Kalam Climate Data.xlsx\n",
            "[83.8s] Structure loaded for Kalam Climate Data.xlsx. Size: (12228, 8)\n",
            "Original Excel columns: ['Date Time', 'Temperature (°C)', 'Dewpoint Temperature (°C)', 'U Wind Component (m/s)', 'V Wind Component (m/s)', 'Total Precipitation (mm)', 'Snowfall (mm)', 'Snow Cover (%)']\n",
            "[83.8s] Renaming Excel columns...\n",
            "Columns after renaming: ['date_time_excel', 'temperature', 'dew_point', 'u_wind', 'v_wind', 'precipitation', 'Snowfall (mm)', 'Snow Cover (%)']\n",
            "[83.8s] Calculating wind speed magnitude...\n",
            "Wind speed calculated.\n",
            "[83.8s] Converting Excel date column ('date_time_excel')...\n",
            "[83.8s] Excel date converted.\n",
            "[83.8s] Loaded and initially processed: Kalam Climate Data.xlsx\n",
            "\n",
            "[83.8s] Attempting to load sample submission from: /content/data/SampleSubmission.csv\n",
            "[83.8s] Successfully loaded: SampleSubmission.csv\n",
            "\n",
            "[83.8s] All data loaded successfully.\n",
            "\n",
            "--- MHP Data Info (Post-Processing) ---\n",
            "<class 'pandas.core.frame.DataFrame'>\n",
            "RangeIndex: 39147559 entries, 0 to 39147558\n",
            "Data columns (total 3 columns):\n",
            " #   Column     Dtype         \n",
            "---  ------     -----         \n",
            " 0   timestamp  datetime64[ns]\n",
            " 1   user_id    object        \n",
            " 2   kwh        float64       \n",
            "dtypes: datetime64[ns](1), float64(1), object(1)\n",
            "memory usage: 896.0+ MB\n",
            "\n",
            "--- Climate Data Info (Post-Processing) ---\n",
            "<class 'pandas.core.frame.DataFrame'>\n",
            "RangeIndex: 12228 entries, 0 to 12227\n",
            "Data columns (total 5 columns):\n",
            " #   Column         Non-Null Count  Dtype         \n",
            "---  ------         --------------  -----         \n",
            " 0   timestamp      12228 non-null  datetime64[ns]\n",
            " 1   temperature    12228 non-null  float64       \n",
            " 2   dew_point      12228 non-null  float64       \n",
            " 3   wind_speed     12228 non-null  float64       \n",
            " 4   precipitation  12228 non-null  float64       \n",
            "dtypes: datetime64[ns](1), float64(4)\n",
            "memory usage: 477.8 KB\n",
            "\n",
            "--- Sample Submission Head ---\n",
            "                                          ID  kwh\n",
            "0  2024-09-24_consumer_device_12_data_user_1    0\n",
            "1  2024-09-25_consumer_device_12_data_user_1    0\n",
            "2  2024-09-26_consumer_device_12_data_user_1    0\n",
            "3  2024-09-27_consumer_device_12_data_user_1    0\n",
            "4  2024-09-28_consumer_device_12_data_user_1    0\n"
          ]
        }
      ],
      "source": [
        "# Cell 4: Load Data (Revised with Correct Column Names)\n",
        "\n",
        "import pandas as pd\n",
        "import numpy as np # Make sure numpy is imported\n",
        "import os\n",
        "import time\n",
        "\n",
        "# --- Use the SAME DATA_DIR as verified previously ---\n",
        "# Ensure this is set correctly for your Colab environment\n",
        "DATA_DIR = '/content/data' # Or your Drive path: '/content/drive/MyDrive/Zindi MHP Challenge/data'\n",
        "# ----------------------------------------------------\n",
        "\n",
        "print(\"Loading data with verified column names...\")\n",
        "start_time = time.time()\n",
        "\n",
        "try:\n",
        "    # --- Load MHP Data (CSV) ---\n",
        "    mhp_filename = 'Data.csv'\n",
        "    mhp_path = os.path.join(DATA_DIR, mhp_filename)\n",
        "    print(f\"\\n[{time.time() - start_time:.1f}s] Attempting to load MHP structure from: {mhp_path}\")\n",
        "\n",
        "    # Columns verified as correct in Data.csv\n",
        "    mhp_cols_to_load = ['date_time', 'Source', 'kwh']\n",
        "    print(f\"Loading only columns: {mhp_cols_to_load}\")\n",
        "\n",
        "    mhp_data_raw = pd.read_csv(\n",
        "        mhp_path,\n",
        "        usecols=mhp_cols_to_load,\n",
        "        #engine='python'  Keep if C engine failed\n",
        "    )\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Structure loaded for {mhp_filename}. Size: {mhp_data_raw.shape}\")\n",
        "\n",
        "    # Convert date column AFTER loading\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Converting MHP date column ('date_time')...\")\n",
        "    mhp_data_raw['timestamp'] = pd.to_datetime(mhp_data_raw['date_time'], errors='coerce')\n",
        "    if mhp_data_raw['timestamp'].isnull().any():\n",
        "        print(\"Warning: Some MHP date conversions failed (resulted in NaT).\")\n",
        "    mhp_data_raw.drop(columns=['date_time'], inplace=True) # Drop original string column\n",
        "    print(f\"[{time.time() - start_time:.1f}s] MHP date converted.\")\n",
        "\n",
        "    # Rename user ID column (verified as 'Source')\n",
        "    mhp_data_raw.rename(columns={'Source': 'user_id'}, inplace=True)\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Loaded and initially processed: {mhp_filename}\")\n",
        "\n",
        "\n",
        "    # --- Load Climate Data (Excel) ---\n",
        "    climate_filename = 'Kalam Climate Data.xlsx'\n",
        "    climate_path = os.path.join(DATA_DIR, climate_filename)\n",
        "    print(f\"\\n[{time.time() - start_time:.1f}s] Attempting to load Excel structure from: {climate_path}\")\n",
        "    # Load full Excel structure first, do not parse dates yet\n",
        "    climate_data_raw = pd.read_excel(climate_path)\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Structure loaded for {climate_filename}. Size: {climate_data_raw.shape}\")\n",
        "    print(f\"Original Excel columns: {climate_data_raw.columns.tolist()}\") # Show original names\n",
        "\n",
        "    # --- Rename Excel Columns to Simpler Names ---\n",
        "    # Use the EXACT names found in the verification step\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Renaming Excel columns...\")\n",
        "    climate_rename_map = {\n",
        "        'Date Time': 'date_time_excel', # Temporary name for date\n",
        "        'Temperature (°C)': 'temperature',\n",
        "        'Dewpoint Temperature (°C)': 'dew_point',\n",
        "        'U Wind Component (m/s)': 'u_wind',\n",
        "        'V Wind Component (m/s)': 'v_wind',\n",
        "        'Total Precipitation (mm)': 'precipitation'\n",
        "        # Add other columns here if needed later, e.g., 'Snowfall (mm)': 'snowfall'\n",
        "    }\n",
        "    # Check if all expected columns exist before renaming\n",
        "    missing_cols = [col for col in climate_rename_map.keys() if col not in climate_data_raw.columns]\n",
        "    if missing_cols:\n",
        "         raise KeyError(f\"Missing expected columns in Excel file: {missing_cols}\")\n",
        "\n",
        "    climate_data_raw.rename(columns=climate_rename_map, inplace=True)\n",
        "    print(f\"Columns after renaming: {climate_data_raw.columns.tolist()}\")\n",
        "\n",
        "    # --- Calculate Wind Speed Magnitude ---\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Calculating wind speed magnitude...\")\n",
        "    climate_data_raw['wind_speed'] = np.sqrt(climate_data_raw['u_wind']**2 + climate_data_raw['v_wind']**2)\n",
        "    # Drop original U/V components if no longer needed\n",
        "    # climate_data_raw.drop(columns=['u_wind', 'v_wind'], inplace=True)\n",
        "    print(f\"Wind speed calculated.\")\n",
        "\n",
        "    # --- Convert Date Column AFTER Loading and Renaming ---\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Converting Excel date column ('date_time_excel')...\")\n",
        "    climate_data_raw['timestamp'] = pd.to_datetime(climate_data_raw['date_time_excel'], errors='coerce')\n",
        "    if climate_data_raw['timestamp'].isnull().any():\n",
        "        print(\"Warning: Some Excel date conversions failed (resulted in NaT).\")\n",
        "    # Drop original date column AFTER successful conversion\n",
        "    climate_data_raw.drop(columns=['date_time_excel'], inplace=True)\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Excel date converted.\")\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Loaded and initially processed: {climate_filename}\")\n",
        "\n",
        "\n",
        "    # --- Load Sample Submission (CSV) ---\n",
        "    sample_sub_filename = 'SampleSubmission.csv'\n",
        "    sample_sub_path = os.path.join(DATA_DIR, sample_sub_filename)\n",
        "    print(f\"\\n[{time.time() - start_time:.1f}s] Attempting to load sample submission from: {sample_sub_path}\")\n",
        "    sample_sub = pd.read_csv(sample_sub_path)\n",
        "    print(f\"[{time.time() - start_time:.1f}s] Successfully loaded: {sample_sub_filename}\")\n",
        "\n",
        "    total_time = time.time() - start_time\n",
        "    print(f\"\\n[{total_time:.1f}s] All data loaded successfully.\")\n",
        "\n",
        "# --- Keep the SAME except blocks as before ---\n",
        "except FileNotFoundError as e:\n",
        "    print(f\"\\n--- ERROR: File Not Found ---\")\n",
        "    print(f\"{e}\")\n",
        "    print(f\"Please ensure files are directly in the '{DATA_DIR}' directory confirmed in Step 1.\")\n",
        "    raise\n",
        "except ImportError as e:\n",
        "     print(f\"\\n--- ERROR: Missing Library ---\")\n",
        "     print(f\"{e}\")\n",
        "     print(\"Failed loading Excel file. Ensure openpyxl is installed (`!pip install openpyxl`).\")\n",
        "     raise\n",
        "except ValueError as e:\n",
        "    print(f\"\\n--- ERROR: Value Error during loading/parsing ---\")\n",
        "    print(f\"{e}\")\n",
        "    print(\"This might be due to an incorrect column name during processing. Verify names from Step 2.\")\n",
        "    raise\n",
        "except KeyError as e:\n",
        "    print(f\"\\n--- ERROR: Key Error ---\")\n",
        "    print(f\"{e}\")\n",
        "    print(\"This usually means a specified column name was not found during renaming or processing. Verify names from Step 2.\")\n",
        "    raise\n",
        "except Exception as e:\n",
        "     print(f\"\\n--- ERROR: An unexpected error occurred during data loading ---\")\n",
        "     print(f\"{e}\")\n",
        "     raise\n",
        "\n",
        "# --- Display Info (Optional but recommended) ---\n",
        "# Select only the columns we will actually use going forward to keep info clean\n",
        "mhp_final_cols = ['timestamp', 'user_id', 'kwh']\n",
        "climate_final_cols = ['timestamp', 'temperature', 'dew_point', 'wind_speed', 'precipitation'] # Add others like 'snowfall' if needed\n",
        "\n",
        "if 'mhp_data_raw' in locals():\n",
        "    print(\"\\n--- MHP Data Info (Post-Processing) ---\")\n",
        "    mhp_data_raw[mhp_final_cols].info() # Show info only for relevant columns\n",
        "if 'climate_data_raw' in locals():\n",
        "    print(\"\\n--- Climate Data Info (Post-Processing) ---\")\n",
        "    climate_data_raw[climate_final_cols].info() # Show info only for relevant columns\n",
        "if 'sample_sub' in locals():\n",
        "    print(\"\\n--- Sample Submission Head ---\")\n",
        "    print(sample_sub.head())"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "f2115812",
      "metadata": {
        "id": "f2115812"
      },
      "source": [
        "## 3. Data Preprocessing and Aggregation\n",
        "\n",
        "The MHP data is recorded at 5-minute intervals, but the prediction target is daily kWh per user. Climate data might also be at a finer granularity than daily.\n",
        "\n",
        "We need to:\n",
        "1.  Aggregate the MHP `kwh` readings to get the total daily sum for each `user_id`.\n",
        "2.  Aggregate the climate data to daily statistics (e.g., mean temperature, total precipitation).\n",
        "3.  Merge the aggregated daily MHP data with the aggregated daily climate data.\n",
        "4.  Handle any missing values that might arise from the merge or exist in the original data."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "id": "c2981e61",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "collapsed": true,
        "id": "c2981e61",
        "outputId": "be4cdaa4-3dcc-4f26-d120-15bca5b992dd"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Aggregating data to daily level...\n",
            "\n",
            "[14.7s] Grouping MHP data by user_id and date...\n",
            "[26.0s] MHP aggregation complete.\n",
            "Aggregated MHP data shape: (136409, 3)\n",
            "Aggregated Daily kWh per User Head:\n",
            "                          user_id       date  daily_kwh\n",
            "0  consumer_device_10_data_user_1 2024-07-22   0.024330\n",
            "1  consumer_device_10_data_user_1 2024-07-23   0.103560\n",
            "2  consumer_device_10_data_user_1 2024-07-24   0.137543\n",
            "3  consumer_device_10_data_user_1 2024-07-25   0.121011\n",
            "4  consumer_device_10_data_user_1 2024-07-26   0.000000\n",
            "\n",
            "[26.0s] Aggregating climate data...\n",
            "[26.0s] Climate aggregation complete.\n",
            "Aggregated climate data shape: (511, 5)\n",
            "Columns after renaming: {daily_climate.columns.tolist()}\n",
            "Aggregated Daily Climate Head:\n",
            "        date  temp_mean  dew_point_mean  wind_speed_mean  precip_sum\n",
            "0 2023-06-03   1.860280       -3.348664         0.680343    0.004557\n",
            "1 2023-06-04   3.992740       -1.905203         0.672389    0.024096\n",
            "2 2023-06-05   4.794523       -3.781657         0.679359    0.011580\n",
            "3 2023-06-06   6.304390       -4.670615         0.574538    0.008914\n",
            "4 2023-06-07   7.003922       -3.965763         0.640492    0.008649\n",
            "\n",
            "[26.0s] Merging aggregated daily MHP and climate data...\n",
            "[26.1s] Merge complete. Initial merged shape: (136409, 7)\n",
            "\n",
            "[26.1s] Checking NaNs before fill:\n",
            "user_id            0\n",
            "date               0\n",
            "daily_kwh          0\n",
            "temp_mean          0\n",
            "dew_point_mean     0\n",
            "wind_speed_mean    0\n",
            "precip_sum         0\n",
            "dtype: int64\n",
            "\n",
            "[26.2s] FillNA complete. NaNs remaining: 0\n",
            "\n",
            "[26.2s] Cell 6 processing finished.\n",
            "\n",
            "--- Merged & Cleaned Training Data Head ---\n",
            "                          user_id       date  daily_kwh  temp_mean  \\\n",
            "0  consumer_device_10_data_user_1 2024-07-22   0.024330  14.719596   \n",
            "1  consumer_device_10_data_user_1 2024-07-23   0.103560  13.217268   \n",
            "2  consumer_device_10_data_user_1 2024-07-24   0.137543  12.462190   \n",
            "3  consumer_device_10_data_user_1 2024-07-25   0.121011  13.867551   \n",
            "4  consumer_device_10_data_user_1 2024-07-26   0.000000  15.572609   \n",
            "\n",
            "   dew_point_mean  wind_speed_mean  precip_sum  \n",
            "0        8.280669         0.439644    0.073049  \n",
            "1        9.862700         0.547125    0.121921  \n",
            "2        9.865658         0.656740    0.119984  \n",
            "3        8.973798         0.661945    0.034283  \n",
            "4        9.434734         0.788089    0.006961  \n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "<ipython-input-5-1e8fee3ca695>:92: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n",
            "  df_train_full.fillna(method='ffill', inplace=True)\n",
            "<ipython-input-5-1e8fee3ca695>:93: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n",
            "  df_train_full.fillna(method='bfill', inplace=True)\n"
          ]
        }
      ],
      "source": [
        "# Cell 6: Data Preprocessing and Aggregation (Corrected Syntax)\n",
        "\n",
        "print(\"Aggregating data to daily level...\")\n",
        "agg_start_time = time.time() # Start timer for aggregation\n",
        "\n",
        "# --- MHP Data Aggregation ---\n",
        "# Ensure required columns exist from Cell 4 processing\n",
        "if 'timestamp' not in mhp_data_raw.columns: raise KeyError(\"Column 'timestamp' not found in mhp_data_raw.\")\n",
        "if 'user_id' not in mhp_data_raw.columns: raise KeyError(\"Column 'user_id' not found in mhp_data_raw.\")\n",
        "if 'kwh' not in mhp_data_raw.columns: raise KeyError(\"Column 'kwh' not found in mhp_data_raw.\")\n",
        "\n",
        "mhp_data = mhp_data_raw.copy()\n",
        "# Extract date from the timestamp\n",
        "mhp_data['date'] = mhp_data['timestamp'].dt.date\n",
        "\n",
        "# Group by the user ID (already named 'user_id') and the date, then sum the kWh for that day\n",
        "print(f\"\\n[{time.time() - agg_start_time:.1f}s] Grouping MHP data by user_id and date...\")\n",
        "# This can be memory intensive for 40M rows. Monitor Colab RAM.\n",
        "daily_kwh = mhp_data.groupby(['user_id', 'date'])['kwh'].sum().reset_index()\n",
        "print(f\"[{time.time() - agg_start_time:.1f}s] MHP aggregation complete.\")\n",
        "daily_kwh.rename(columns={'kwh': 'daily_kwh'}, inplace=True)\n",
        "# Convert date back to datetime object for merging and feature engineering\n",
        "daily_kwh['date'] = pd.to_datetime(daily_kwh['date'])\n",
        "print(f\"Aggregated MHP data shape: {daily_kwh.shape}\")\n",
        "print(\"Aggregated Daily kWh per User Head:\")\n",
        "print(daily_kwh.head())\n",
        "\n",
        "\n",
        "# --- Climate Data Aggregation (Using simplified names from Cell 4) ---\n",
        "# --- Climate Data Aggregation (Using simplified names from Cell 4 - CORRECTED .agg() call) ---\n",
        "# Ensure required columns exist\n",
        "if 'timestamp' not in climate_data_raw.columns: raise KeyError(\"Column 'timestamp' not found in climate_data_raw.\")\n",
        "\n",
        "climate_data = climate_data_raw.copy()\n",
        "# Extract date from the timestamp\n",
        "climate_data['date'] = climate_data['timestamp'].dt.date\n",
        "\n",
        "# Define the columns to aggregate and the aggregation function\n",
        "climate_agg_dict = {\n",
        "    'temperature': 'mean',\n",
        "    'dew_point': 'mean',\n",
        "    'wind_speed': 'mean',\n",
        "    'precipitation': 'sum'\n",
        "    # Add 'u_wind':'mean', 'v_wind':'mean' if you want to keep daily components\n",
        "}\n",
        "# Check if needed columns exist in climate_data before aggregation\n",
        "required_climate_cols = list(climate_agg_dict.keys())\n",
        "missing_climate_cols = [col for col in required_climate_cols if col not in climate_data.columns]\n",
        "if missing_climate_cols:\n",
        "    raise KeyError(f\"Missing required climate columns for aggregation: {missing_climate_cols}. Check Cell 4 processing.\")\n",
        "\n",
        "print(f\"\\n[{time.time() - agg_start_time:.1f}s] Aggregating climate data...\")\n",
        "\n",
        "# --- CORRECTED .agg() call ---\n",
        "# Pass the dictionary directly as the argument\n",
        "daily_climate = climate_data.groupby('date').agg(climate_agg_dict).reset_index()\n",
        "\n",
        "# Rename columns to include the aggregation type (e.g., temp_mean) - important!\n",
        "# Create the names expected by later cells (e.g., 'temp_mean', not 'temperature_mean')\n",
        "rename_map = {\n",
        "    'temperature': 'temp_mean',\n",
        "    'dew_point': 'dew_point_mean',\n",
        "    'wind_speed': 'wind_speed_mean',\n",
        "    'precipitation': 'precip_sum'\n",
        "}\n",
        "# Only rename columns that were actually aggregated\n",
        "rename_map = {k: v for k, v in rename_map.items() if k in daily_climate.columns}\n",
        "daily_climate.rename(columns=rename_map, inplace=True)\n",
        "# --- End of Correction ---\n",
        "\n",
        "\n",
        "print(f\"[{time.time() - agg_start_time:.1f}s] Climate aggregation complete.\")\n",
        "\n",
        "# Convert date back to datetime object\n",
        "daily_climate['date'] = pd.to_datetime(daily_climate['date'])\n",
        "print(f\"Aggregated climate data shape: {daily_climate.shape}\")\n",
        "print(\"Columns after renaming: {daily_climate.columns.tolist()}\") # Verify names\n",
        "print(\"Aggregated Daily Climate Head:\")\n",
        "print(daily_climate.head())\n",
        "\n",
        "\n",
        "\n",
        "# --- Merge Aggregated Data ---\n",
        "print(f\"\\n[{time.time() - agg_start_time:.1f}s] Merging aggregated daily MHP and climate data...\")\n",
        "df_train_full = pd.merge(daily_kwh, daily_climate, on='date', how='left')\n",
        "print(f\"[{time.time() - agg_start_time:.1f}s] Merge complete. Initial merged shape: {df_train_full.shape}\")\n",
        "\n",
        "# --- Handle Missing Values ---\n",
        "print(f\"\\n[{time.time() - agg_start_time:.1f}s] Checking NaNs before fill:\\n{df_train_full.isnull().sum()}\")\n",
        "# Sort before filling for consistent ffill/bfill\n",
        "df_train_full.sort_values(by=['user_id', 'date'], inplace=True)\n",
        "df_train_full.fillna(method='ffill', inplace=True)\n",
        "df_train_full.fillna(method='bfill', inplace=True)\n",
        "nan_count_after = df_train_full.isnull().sum().sum()\n",
        "print(f\"\\n[{time.time() - agg_start_time:.1f}s] FillNA complete. NaNs remaining: {nan_count_after}\")\n",
        "\n",
        "agg_total_time = time.time() - agg_start_time\n",
        "print(f\"\\n[{agg_total_time:.1f}s] Cell 6 processing finished.\")\n",
        "print(\"\\n--- Merged & Cleaned Training Data Head ---\")\n",
        "print(df_train_full.head())"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# Cell 7A: Exploratory Data Analysis (Post-Aggregation)\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "\n",
        "print(\"--- EDA on Aggregated Data (df_train_full) ---\")\n",
        "\n",
        "# 1. Distribution of the Target Variable (daily_kwh)\n",
        "plt.figure(figsize=(10, 5))\n",
        "sns.histplot(df_train_full['daily_kwh'], bins=100, kde=False)\n",
        "plt.title('Distribution of Daily kWh Consumption')\n",
        "plt.xlabel('Daily kWh')\n",
        "plt.ylabel('Frequency')\n",
        "# Optionally zoom in if outliers dominate\n",
        "# plt.xlim(0, df_train_full['daily_kwh'].quantile(0.99)) # Zoom to 99th percentile\n",
        "plt.show()\n",
        "# Observation: Is the distribution heavily skewed? Many low values?\n",
        "\n",
        "# 2. Consumption Over Time (Sample Users)\n",
        "# Select a few user IDs to plot\n",
        "sample_user_ids = df_train_full['user_id'].unique()[:3] # Get first 3 unique users\n",
        "print(f\"\\nPlotting time series for sample users: {sample_user_ids}\")\n",
        "\n",
        "plt.figure(figsize=(15, 6))\n",
        "for user in sample_user_ids:\n",
        "    user_data = df_train_full[df_train_full['user_id'] == user]\n",
        "    plt.plot(user_data['date'], user_data['daily_kwh'], label=user, alpha=0.8)\n",
        "\n",
        "plt.title('Daily kWh Consumption Over Time (Sample Users)')\n",
        "plt.xlabel('Date')\n",
        "plt.ylabel('Daily kWh')\n",
        "plt.legend()\n",
        "plt.show()\n",
        "# Observation: Do users have different base levels? Similar seasonal patterns? Weekday/weekend patterns?\n",
        "\n",
        "# 3. Average Consumption by Day of Week\n",
        "plt.figure(figsize=(10, 5))\n",
        "df_train_full.groupby('dayofweek')['daily_kwh'].mean().plot(kind='bar')\n",
        "plt.title('Average Daily kWh by Day of Week (0=Mon, 6=Sun)')\n",
        "plt.xlabel('Day of Week')\n",
        "plt.ylabel('Average Daily kWh')\n",
        "plt.xticks(rotation=0)\n",
        "plt.show()\n",
        "# Observation: Is there a clear weekly pattern (e.g., lower on weekends)?\n",
        "\n",
        "# 4. Average Consumption by Month\n",
        "plt.figure(figsize=(10, 5))\n",
        "df_train_full.groupby('month')['daily_kwh'].mean().plot(kind='bar')\n",
        "plt.title('Average Daily kWh by Month')\n",
        "plt.xlabel('Month')\n",
        "plt.ylabel('Average Daily kWh')\n",
        "plt.xticks(rotation=0)\n",
        "plt.show()\n",
        "# Observation: Is there clear seasonality?\n",
        "\n",
        "print(\"\\n--- End of EDA ---\")"
      ],
      "metadata": {
        "collapsed": true,
        "id": "kN4RxCaDzHUl",
        "outputId": "5f79129e-4fb9-4b9a-9de0-9a7a4b22e69c",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        }
      },
      "id": "kN4RxCaDzHUl",
      "execution_count": 18,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "--- EDA on Aggregated Data (df_train_full) ---\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1000x500 with 1 Axes>"
            ],
            "image/png": "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hnbt2qVnnnlGVqvVtl5GRobmz5+vSZMmae3atapXr54mT558xWe4pIu3b06YMEEPPvig1q5dq48++kh5eXkaMGCAjh07ppCQEG3evFmS9PTTT2v79u0lhoRrcXFxUcuWLW3P8VmtVg0dOlSpqan66KOPtHHjRo0cOVLvv/++Vq5cec39NWjQQCEhIcX6k5SUpN9++02PPvpoqer66aefNGbMGI0YMUKPPfaYHB0d1apVK7uglZ6erp9//tkWLC59FvHnn3/WyZMni92KuGzZMnl4eGjVqlWaM2eOdu/efdVn2Xbv3i2r1aoOHTpccZ177rnHFvRyc3M1YMAAJSUlae7cudqwYYOGDBmiDz74QLNmzbLb7rvvvtO+ffu0cOFCLVu2TKdOndI///lP2/g//vEPZWRk6IMPPtDGjRs1ZswYLV26VB9++GGpXsNLLVy4UCEhIfr000/16KOPasmSJRo4cKDuu+8+xcTE6G9/+5s+/PBD/fe//7Xbbvr06Wrfvr0+++wzTZ48WV988YVmzpwp6eJ71MvLSw8//LC2b9+ukJCQYseNi4vTc889p4YNG2r16tWKjo6Wj4+Phg4davtHlyJvvvmmWrVqpc8++0xjxozR2rVrtWLFius+VwDmQAgDgDIoCgRpaWnFxhISEnTHHXeoZ8+e8vX1VcOGDTV9+nQtXrxYjo6O8vT0VJUqVVS1alXVqlXL7jmfsLAwPfjgg7rrrruueOxz585p1qxZatiwoYKCgjRp0iRlZGQUu5XtSpycnOTu7i5J8vDwKPF2x+PHj2v9+vUaNmyYevfurb/+9a9q3769xo8fr8TERO3Zs8e27okTJzR58mQ1bdpU9957rwYPHqy8vDwdOHDgijV88MEHateunUaOHKl69eopKChIc+fOVU5Ojj799FM5OTnJ29tbklS9evUbugXs7rvvtuvTkiVLtHDhQvn7+8vX11ePPPKI/P399d1335VqfxEREdq9e7eOHDliW/bll1/K19dXYWFh19z+0KFDGjZsmB577DENGzbMtrxt27ZKS0vTzz//LOlimHdyclLTpk3VqlUrJSUlKTMzU5K0c+dOSRefJbvUvffeq2eeeUZ169ZVly5dFBoaanf16XInTpyQJPn6+pbq3L/55hsdPnxYb775psLCwvTXv/5VERER6t+/v6Kjo3XhwgXbutnZ2Zo2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1qxZI0lXnV2wJEOHDlWzZs00duxYu+eCmjVrpurVq+uTTz5RixYt7J45bNy4sW2sZcuW1/XHwa/m5Zdf1n333acnnnhCH330kZKTk3Xo0CF9+umnevzxx+Xt7a3XXntN0sUrefXq1dPLL7+s//73v/rjjz+0fPlyrV69WoMGDSp1TVarVVOmTNGkSZN08OBBpaamKi4uTps3b1aLFi0kXbytt0qVKvrwww916NAh7d27V5MmTZKPj0+5nLckbd++XTExMfr999+1du1aff311+rdu7dt3N3dXQcOHFBSUpJOnjxZbPshQ4bot99+05QpU5ScnKykpCSNHj1aubm5evLJJ8utTgDmc+W/fAkAt7mMjAzbbWwWi0UeHh4KDg7Wv/71r2Kz0l1q5MiRcnR01MyZM3XixAlVr15djRo10gcffGALA4MGDdI///lPPf7443rppZfk7+9f6rratGmjBg0a6JlnnlF6eroaNWqkhQsX2ibr6Natm/bu3at///vf+te//qWQkBC9/vrrdrPOBQUFqVOnToqKitKaNWtKnBlwypQp8vLy0uzZs5WWlqYaNWqoc+fOGjNmTKlrvZLevXursLBQUVFRtoDaokULTZ8+vUx/nPrbb7+1PXPn6OioWrVqKSwsTFOmTFG9evVs6zVt2lRjxozR8uXLtWrVKgUFBWnOnDnKzMzUiy++qIiICMXGxpbqmA8++KAcHBzUt2/fq/4h6ZI4ODho9uzZ6tmzpyZNmqR58+ZJujipQ4sWLbR161a7WxGli7fvNW/eXNu2bSuXWxGLeHh46OOPP9by5cu1fv16vfvuu3JwcFDt2rX15JNPKjIy0narq5OTk6KiojRz5kwNHz5cZ8+ela+vr8aOHaunnnqq1MesUaOGoqKi9O677+rJJ59UTk6O7rrrLj300EMaOXKkpIvPq7322mt6//331bNnT9WtW1fjxo3Te++9V27nPnLkSNs/LlgsFvXs2VPDhw+3jT/77LOaPn26IiMj7f5WWpEWLVpowYIFmj9/vvr06SNHR0cFBwdr2bJldu87ALicxVrW+2EAALiNbdq0SS+99JK+/fbbcr06g5tv165dGjBggO1PJQCA0bgSBgDAdTh58qQSEhL0yiuvaPDgwQQwAMB1I4QBAHAdHn/8cZ06dUq9e/fWiy++WNHlAABuQdyOCAAAAAAGYnZE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SW5ubvLx8dGIESP0zTffyMHBwXZFq0hmZqa8vLwkSTVq1Cg2npWVJS8vL9s6l4+fOnVKNWvWlJeXV4nbWiwW27YAAAAAUFaVNoQVFBSosLDQ7qrUhQsXJF2ciOPSKeclKSEhwTYRR2BgoBITE+32deDAAQUHB6t27dry8PCwG//ll1904cIFBQYGKjAwUKmpqbap8CUpPj5e9evXl4uLy005VwAAAAC3j0obwkJCQlS9enXNmzdP58+fV2ZmphYsWKDmzZurV69eSklJUUxMjHJzc7Vt2zZt27ZN/fv3lyRFRkZq7dq12rt3r86fP68FCxbIyclJHTp0kKOjo/r376+FCxcqNTVVmZmZmjt3rjp37ixvb2/5+/srKChIc+bMUXZ2tpKTkxUVFaXIyMgKfkUAAAAAmEGlDWE1atTQhx9+qB9//FHt2rXTI488omrVqmnOnDmqWbOmFi1apBUrVqhZs2Z64403NGvWLDVs2FCS1K5dO7300ksaNWqUWrRoobi4OC1evFjVqlWTJI0YMULBwcHq1auXOnXqJBcXF02fPt127Pfee08nTpxQ69atNWDAAPXu3VuPP/54hbwOAAAAAMzFYi3DLBSRkZHq1auXHnroIXl6et6Esm4taWmVY8ZBi0Xq2qe36kZMLXH81xWTFbt+vcFVoSwslosz65w8eevPEHS7o5fmQS/Ng16aB700DzP1slata8+OWKYrYW3atNGqVavUtm1bDRs2TBs2bFBubm5ZdgUAAAAAt5UyhbAXXnhBa9eu1YYNG9SiRQstX75cbdq00YQJExQXF1feNQIAAACAadzQM2G1a9fW008/raVLl2r06NH65ptv9PTTT6tTp05atWpVedUIAAAAAKZxQ3+seefOnfr888+1adMmubi4KCIiQr1799bJkyc1Y8YMJScna+LEieVVKwAAAADc8soUwmbOnKkNGzbo9OnT6ty5s9599121atVKFotFklS/fn198MEH6t69OyEMAAAAAC5RphCWlJSk0aNHq0uXLqpevXqJ69x555165plnbqg4AAAAADCbMj0T9tFHH8nHx0fHjh2zLdu9e7e2b99ut97QoUNvrDoAAAAAMJkyhbDly5dr+PDhOn78uG3Z6dOnNWbMGK1YsaLcigMAAAAAsylTCIuKitKKFSvUqlUr27JOnTpp+fLlioqKKrfiAAAA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lqenZ7HxyMhIrV27Vnv37tX58+e1YMECOTk5qUOHDobXWp4sVjPeZHkbOnbsmCZPnqz//ve/cnV1VUREhF588UWeH6rkfvjhB/3973+Xk5NTsbGvv/5aZ8+e1auvvqqEhAR5e3vrmWee0eOPP14BleJ6HT16VJ06ddLPP/8sSdq9e7emTZum5ORk+fr6asyYMerSpUsFV4kruXDhgmbMmKEvv/xSeXl56tq1qyZPniwXFxd6eYtJSEjQzJkzdfDgQTk5OalFixYaP368fHx86GUlVxSYiu4IqVKliiTZZsXbtGmT5syZo5SUFNWvX18TJ05U8+bNJV18hmjevHlatWqVzp49q9DQUL322mu66667KuBMcLVevvzyy/rss89sy4o0b95cS5YskST9+9//1uLFi5Wenq6goCBNmTJFDRo0MPAMyh8hDAAAAAAMxO2IAAAAAGAgQhgAAAAAGIgQBgAAAAAGIoQBAAAAgIEIYQAAAABgIEIYAAAAABiIEAYAAAAABiKEAQAAAICBCGEAAFxm7dq16tixoyRp165d8vPzU25u7nXto6zbXY2fn5/+85//lNv+AAAVgxAGADCVjh07KiAgQEFBQQoKClJ4eLjGjx+vX3/9tdT76N27tzZv3nxT6rNarWrVqpVWrlxpt3zTpk3y8/NTYmKi3fIZM2aof//+N6UWAEDFIIQBAExn0qRJio+P148//qh//etfqlGjhv72t79px44dFV2aLBaLWrdurbi4OLvl33//vapXr15seVxcnNq2bWtkiQCAm4wQBgAwrapVq6pevXoaN26cnnzySU2aNEkFBQWSpPj4eD3++ON64IEHFBYWpldffVV5eXmSpE8//VStW7cutr+nnnpKb775pt2y999/XxEREdesJT4+Xs2aNdP333+vtm3bateuXbZaJGnHjh3q06ePXVBMT0/X//73P7sQlpaWpqeeekqNGzdWt27d9Msvv1zfiwIAqHCEMADAbWHgwIE6evSo7Xa/0aNHq2XLltq1a5dWr16tLVu2aNWqVVfdR+/evfXll1+qsLDQtmzTpk3q0aPHVbc7fvy4XnjhBU2YMEGtW7dW27ZtlZ2drf3790uS/vzzTx0/flwDBgzQnj17dOHCBUkXr4J5eHiocePGtn1FR0drypQpiouLk7e3t+bOnVum1wMAUHEIYQCA24K3t7fc3d119OhRSRcn3xg2bJgcHR31l7/8Rc2bN1dCQsJV99GlSxdlZ2dr165dkqQjR44oOTlZDz/88BW3yc3N1QsvvKA+ffqoX79+kiQvLy/5+/vr+++/l3TxVsSmTZuqbt26qlWrlvbs2SPpYggLCwuTg8P//991r169dO+998rV1VUdO3bUoUOHyv6iAAAqBCEMAHDbyM/PtwWanTt36rHHHlNISIiCgoK0YcMG2xWoK3FxcdGDDz6o9evXS7p4Fax169by8vK64jYvv/yyTp48qZEjR9otb9u2rS2E7dixQ61atZIktWrVynZL4s6dO4s9D3bPPffY/tvZ2dl2CyUA4NZBCAMA3BZ+//13nTt3Tvfdd5+Sk5M1cuRI2zNY8fHxeuSRR0q1n969e2vTpk26cOGCvvnmm2veipiTk6P8/PxisyG2bdtW+/fvt11Za9mypSSpZcuW2rFjhw4fPqw///xTbdq0sdvOYrFcx1kDACojQhgA4LYwb948NWjQQA0aNFBSUpKcnJw0YMAAVatWTVarVUlJSaXaT6tWreTi4qKYmBj973//U6dOna66/nvvvadp06Zpzpw5drcONmnSRHfccYfWrFmjCxcuKCAgQNLFEJaUlKStW7eqYcOGuvPOO8t+0gCASokQBgAwtePHj2vGjBn69ttvNX36dEmSr6+vcnJylJSUpFOnTmnWrFlycnLSiRMnZLVar7o/BwcH9ejRQ3PnzlWnTp10xx13XHV9R0dHdejQQd26ddO4ceNsMyJWqVJFYWFhWr58uVq0aCFHR0dJUs2aNVW3bl2tXLmSqekBwKQIYQAA05k2bZqCgoIUGBionj176vjx44qJibHNMhgSEqK///3veuKJJ9S9e3f5+vrq5Zdf1i+//KLRo0dfc/+9e/dWdnb2NW9FvFTRs2GLFi2yLWvbtq2OHDliuxWxSMuWLfXHH38QwgDApCzWa/2THwAAsLNz5069/PLLio2NtZu5EACA0uD/HAAAXIcTJ07ojTfe0ODBgwlgAIAy4f8eAACU0qJFi/Twww+refPmioyMrOhyAAC3KG5HBAAAAAADcSUMAAAAAAxECAMAAAAAAxHCAAAAAMBAhDAAAAAAMBAhDAAAAAAMRAgDAAAAAAMRwgAAAADAQIQwAAAAADDQ/wOTkvP5EhBI6wAAAABJRU5ErkJggg==\n"
          },
          "metadata": {}
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\n",
            "Plotting time series for sample users: ['consumer_device_3_data_user_9' 'consumer_device_3_data_user_4'\n",
            " 'consumer_device_3_data_user_3']\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1500x600 with 1 Axes>"
            ],
            "image/png": "iVBORw0KGgoAAAANSUhEUgAABMYAAAIcCAYAAAAdeKK/AAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAAs5hJREFUeJzs3Xd8FOXaxvFrNpUEQu9SLIjSexNUQAQUBCm+oIiIiBzFQhMQFD1KFaQIgmJBUVRABBQUxUIvdukcQVpAQpESIGWz8/6R3cluCtmEsgvz+34+HrI7szNPNo9n5cr93I9hmqYpAAAAAAAAwGYcgR4AAAAAAAAAEAgEYwAAAAAAALAlgjEAAAAAAADYEsEYAAAAAAAAbIlgDAAAAAAAALZEMAYAAAAAAABbIhgDAAAAAACALRGMAQAAAAAAwJYIxgAAAAAAAGBLBGMAgKvakCFDVLFiReufKlWq6Pbbb9czzzyjdevW5eqar7/+uipWrKjExERJ0oMPPqj77rvvgsZZsWJFjR8/PtNj48eP10033aTjx49nOPbAAw+oevXqSkpKynCsefPmevDBByVJzZo105AhQ3I9vqVLl6pHjx6qV6+eqlatqmbNmmno0KHasWNHrq95tTlw4IAqVqyojz/++LLdMzExUbNmzVKnTp1Uu3ZtVa1aVXfeeadeeeUV/fPPP5dtHOktWLDA59+7rP4JxHuWmV27dqlOnTr66quvrOdWrVqlPn366NZbb1XlypVVp04dPfDAA/r2228DONKM0v//UW5l9/9jzZo1U79+/S7oHhfDpk2bVKNGDa1duzbQQwEAXCUIxgAAV71ChQpp9erVWr16tZYtW6bRo0crOjpaPXv21JgxY3J8vZ49e2r16tWKiIi4BKPNqHHjxjJNU+vXr/d5/syZM/rjjz+UmJioX375xefY/v37deDAATVp0uSC7m2app599lkNHTpUtWvX1gcffKClS5dq2LBh2r17tzp37qwffvjhgu5xpVq/fr2aNWtmPS5ZsqRWr16te++997Lc/9SpU3rggQf0zjvvqGPHjpo7d66++uorDR48WJs2bdI999yj33///bKMJb277rrL+ndu9erVGjhwoCRp3rx5Ps9f7vcsM2fOnNHjjz+u9u3bq3Xr1pKkRYsWqVevXipTpozeeustLV++XDNnzlSxYsX05JNPatmyZQEbr91VrVpVgwYNUr9+/XTgwIFADwcAcBUIDfQAAAC41BwOh4oWLWo9Ll26tBo2bKiGDRtqwIABuuGGG9SpUye/rxcdHa3o6OhLMdRM1a5dW1FRUVq9erXuuusu6/mNGzcqNDRU1atX17p169SwYUPrmKea4kKDsY8//liLFi3Sm2++qdtvv916vkyZMmrSpIm6d++uUaNGqUmTJgoNtdd/Vvz2228+j0NCQnzm2aX23//+V/v379fnn3+uUqVKWc9fc801atKkiXr27Kmnn35ay5YtU2Rk5GUblyRFRkb63DNv3rySUkPq9O/R5XzPMvPOO+/o33//1dNPP2099+GHH6p27doaNmyY9VzJkiVVo0YNnTlzRr///rtatmwZiOFCUteuXfXxxx9rwoQJmjhxYqCHAwC4wlExBgCwrTZt2qhhw4Z66623rOfOnDmjV155RU2aNFHlypV166236rnnntO///5rnZPV0qXk5GQ1btw40yWLL7zwgpo0aaKUlBS/xrZv3z41atRIAwcOVGhoqBo0aJBh6dDatWtVtWrVTJcVrV27VkWLFtVNN93k8/yiRYvUokULValSRXfffbd+/fXX847j3Xff1S233OITinmEh4fr9ddf1+LFi61QLCkpSRMmTFCzZs1UpUoVNWrUSEOGDNGxY8es1w0ZMkTt2rXThg0b1KFDB1WvXl0tWrTQ559/bp2TlJSkMWPGqFmzZqpatapuueUWDR482Po5ZLUEb8iQIbrlllusx82aNdN///tfzZw5U02aNFH16tX12GOP6dSpU/rggw/UtGlT1apVS48//rhOnTplva5ixYqaPn26Jk6cqFtuuUXVqlVT9+7dtWfPHus+kyZNUmxsrCpWrKjXX3890zHt2rVLffr0UZ06dVSlShXdddddmj17ts+YK1asqFmzZun1119XkyZNVLNmTZ97Zeaff/7RkiVL9Mgjj/iEYt4/myFDhuiff/7R0qVLtW/fPlWsWFGffvpphnNbt26t//znP5JSKwRnzZqldu3aqUaNGmrUqJFeeOEFn/fG8/P7+OOPVa9ePY0dOzbLcWYn/XvmWYL5xx9/6MEHH1T16tV1++23a/HixTp48KB69uypmjVrqnnz5lq6dKnPtf744w898sgjatSokWrUqKEHHngg2/kdHx+v9957T926dVO+fPms5xMSEpSc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v/56jR8/XuvXr9fMmTN9jtevX1/h4eFatmyZDh48qEaNGlnHqlevrjx58ujjjz/WuXPnMvQXy61HHnlEv//+uz777LMMx5KSkjRs2DCNHTtWZ86cUZUqVeRwODL0/PH0Fqtatapf93S5XPrmm2+sUCk8PFy33367nnrqKcXGxurkyZNWKODdxNvpdGrz5s25+j4zk/778CzJu+6666znzjcnqlWrpv3792foSfXLL7/o+uuvz7Qvmb+KFCmidu3a6YMPPtDff/+d4XhycrLGjRuncuXKqUWLFtbzLVq0UGhoqH788UctW7ZM99xzjxUyXnvttYqJidH+/ftVrlw5659rrrlGTqfzvJVXgVajRg39/fffKlmypM/YTdPMsJTVW7FixXT06FGfDSg2b96sOnXq+CyH9nbgwAGFh4erYMGCmf5/xoEDB7Rhwwa///8iO3v37vWZQ3v37lV8fLzPPPSIjo7WjTfeqL///tvnfShXrpySkpJUuHDhLO/TpEkTxcbGWr0Kvc2ZM0dJSUlq3ry5pNQq0u+//946XqZMGfXr108VKlSwdtWsUaOGdu3alWEcTqczw5JIb4cPH/Zpsl+sWDE98sgjuuWWWzL0Xzty5Mh5f74AAPiDYAwAcNVzuVw6cuSIjhw5osOHD+u3337T888/r5EjR+qxxx6zgoPrrrtO+fPn10cffaS///5bv//+u3r16qU77rhDkrRhw4bz7k7nrXPnztqzZ4++/fbbTCs3zqdOnTrq06ePJk+erD/++MN6Pk+ePKpdu7bmzp2r/Pnzq1KlStax8PBw1a5dW59++qkKFCigatWq5eieWenYsaM6duyo559/XqNGjdLmzZt14MABrVixQg8++KB27typSZMmKW/evCpatKjuvfdeawfG/fv367vvvtPo0aNVv359v8fkcDj09ttv65lnntHPP/+sQ4cOacuWLfrkk0904403qkCBAsqXL5/Kly+vRYsW6c8//9Rff/2l559/XmFhYRfl+5ZSl0yOHj1au3bt0oYNG/TGG2+oWrVquv766yWlVikdOXJEP//8s/bv35/h9R06dFCBAgXUr18//fnnn/r77781ZcoUrVy5Ur17977g8Q0dOlTXX3+97r//fs2ePVu7du3SgQMH9MMPP+jBBx/U7t27NWXKFJ/3JDo6Ws2aNdP777+v2NhYazdKSQoNDVWvXr308ccf64MPPtCePXu0bds2DR06VJ07d84Q8AWT7t2768yZMxowYIA2bdqk/fv3a+7cuWrfvr0+/fTTLF9Xt25dnT171qcPWZUqVXTHHXfov//9r6ZOnapNmzbp4MGD2rx5s1577TV9+OGH6tWrl/LkyaMqVaooNDRU7777rvbv369169bpiSeeUOvWrXXixAlt3br1gneCzJ8/v5577jlt2bJF27dv13//+19FRkaqdevWmZ7/2GOP6bvvvtPrr7+uXbt26a+//tLYsWN17733nrfHWNu2bdWgQQMNHDhQCxYs0J49e7R9+3ZNnTpVr732mrp27apatWpJSq0U7du3r9577z3t2bNHsbGxWrBggf7++2+rQX6vXr20Y8cOvfjii9q+fbv27Nmjt956S23bttWKFSuyHMepU6c0YMAATZgwQX/99ZcOHTqk5cuX69dff1W9evV8ztuxY4dPQ34AAHKDpZQAgKue93IywzCUP39+Va9eXW+//bbPMrOoqCiNHz9eo0ePVrt27VSuXDk988wzqlmzpn777Tc99dRTeuONN/y6Z/HixVWrVi0lJyfnqkn5E088obVr16p///5auHChtVyoSZMmWrdune68884MS8QaNmyo1atX66677jrv8rGcGjVqlJo0aaJPP/1UPXv2VEJCgkqWLKkmTZpo4sSJPjsjvvjiiypUqJDGjx+vI0eOqGDBgmrRooUGDBiQo3tOmzZNY8eO1dNPP62TJ0+qYMGCqlevnl566SXrnHHjxunFF19Ut27dVLBgQfXo0UOFCxfOstInp+655x6Fhoaqe/fuOnXqlGrWrKmRI0dax7t27arVq1erR48e6tq1qx566CGf1xcqVEizZ8/WuHHj9PDDDysxMVHXXXedxo4dq/bt21/w+PLly6ePPvpIc+bM0eLFizVx4kQlJyerVKlSatq0qaZOnaoiRYpkeF3btm31n//8R1WrVvVpBi+lhirR0dH66KOPNG7cOIWHh6tu3br66KOPfBrAB5ty5cpp9uzZmjhxorp3767k5GSVL19egwcP9llynN4tt9yiqKgo/fDDDz4VjZMmTdInn3yiL774QnPmzNHJkycVHR2tm2++Wa+++qratGkjKbXX28iRIzVlyhS1adNGN954o1544QUVLFhQP/30kx544AHNmzfvgr63MmXK6N5771X/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eR/n6nqVK1dRvnwx+uij95WUlKQ//vhda9euztH9mjVroY0b12nDhvVq1qxFpve56642+u23X7RmzSo5nU7NnTtH8+d/oujovGrbtr02bfpDS5YsVnJysv73vx3q3buHfvwx+80DSpcuo+joaE2aNF6nT5/W2bNnNGPGVJUufY3Kl78229c3aNBIGzemLhtMTEzQe+/N9KmYK1GipLZu3Syn06n169daGw14QqeIiAjFxsYqPj5eJUuWUmJiov73vx06deqUpk+forCwcB09etQnWMzKNdeU1ZYtmxUXd1jx8fH6+OPZVvXf5s1/6v77O2nbti0yTVP//ntc+/fvVenSZZQ3b141b36npk+fori4w0pMTNCMGVP1zDNP+HXf9CpXrqrPPvtS7703x/rnppsqqVevxzR48PM5vl5OEIwBAOzJqhgL7DAAAIA9zJgxQ4cOHVLbti307LP91KNHLzVseItGj56go0ePqEOHu/XYYw+rUqUq6t9/cLbXi4iI1CuvjNWnn36kVq1uV8eObRQXF2ft5te1a3fly5dX997bWv3799V9992fzRWzlj9/AY0ZM0ErV/6o1q2b6cknH9Mtt9yqLl265ep6ERGRGj16vFavXqHWrZvq3XffUpcuD+TofnXq1NORI0dUrFgxXXfd9Znep0KFinrhhZc1adKratXqdq1Zs1JjxkxQaGioypUrrxEjRmrOnA/UsuXtGjbsWXXt2k3Nm2cesnkLCQnRq69O1rlzZ9Whw13q1OkeHT9+TOPGTVJYWFi2r2/WrIU6d+6qwYP7q0OHuxUWFqbKlatYx/v3f1YrVvyg1q2b6csvF+qll0apUqUqeuSRbjp+/Jjatm2vBQvmqm/f3qpSpZo6dLhPffv21oMP3qcSJUrp6acHateuvzRiRPabAbRp004VK96s++/vqF69HlSLFq2spYxVqlTTQw89ohdeGKrmzRurZ89uqlSpijp06CxJ6tdvkEqXLqMHH7xP7dq11p49uzVmzAS/e815Cw8PV7FixX3+CQsLU758MSpYsGCOr5cThpmbKC8IHTlyOtBDQAAYhlSkSD4dPXqa1VAIGszLK0P+xQ/ISPhXZmQBnbxnTqCHc0kwFxEsmIsIJOYfggHzEMHCTnOxaNF8fp1HxRgAwJ6sijGWUgIAAAB2xa6UAAB7crErJQAAwKXQqtXt523M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buL666/vnochWdWda9GzePFi1q1bx+mnn97utXR0vkgkwoUXXsg999zTLc9Cel4+rb9Bgwbx61//mkmTJmHbNlOnTuWII47gk08+6ZZnIz0rn9ai9F75vA7z9ftnBWPS7fr27cs999xDZWVl5mNbt25l0KBBrF69mrFjx+Lz+TKvjR8/PtMqduqpp3LttddmXksmk+zcuZPBgwcDMH36dI455hgAotEoTz31FLZtc+KJJ7Z5LR2dr7m6ujoeeeQRbrrppoO4e8lF+bYmLctq8Z5+/fqxZs2aA719ySG5tBYBvv/97xMMBtt8bdy4cXzhC1848JuVnNadaxFSa/DOO+/k9ttvx+/3t3stHZ2vsrKSb37zmwd3w5JT8mn9TZo0iRkzZgCplt4XXniBTZs2ccYZZxzEE5BckU9r0bu273znO0ybNo2ZM2fyl7/85cBvXnJGvq1DTz5//6xgTHrcypUreeqpp5g9ezY1NTX07du3xevl5eXU1NTguu5e7/3lL39JSUkJ5513XouP33bbbUyePJnHH3+cBx98kIEDB7Z57v0531NPPcW0adM48sgjD+Q2JY/k8po844wzeP7551m6dCnxeJyXX36ZFStWUFtbe5B3Lbkom2tRpLmuXosPPvggkydPZvr06R2ee3/PJ71PPqy/hx56iEmTJnHnnXdy7733Mm7cuP29TckDubwWKyoqOPTQQ7npppv417/+xY9+9CNuvfVW3n777QO8W8lVubwOm8vn758VjEmPWrZsGVdccQU33HBD5qdtbWldIWOM4f777+fvf/87Dz/8MKFQqMXrd911F++//z7XXnstV199NR9++OF+XVfr8zmOwx//+Ecuv/zy/TqO5J9cX5Nf+cpX+O53v8vNN9/MySefzJtvvslZZ53V4qc20jvk6lqUwtPVa3HdunX8+c9/Zs6cOQd1Xa3PJ71Tvqy/a665hhUrVvDzn/+cn/zkJyxevPigji+5J9fX4umnn85jjz3G+PHjCQaDnH/++Zx11lnMnz//oI4vuSXX16En379/VjAmPWbRokV8//vf59Zbb838B1NRUUF1dXWLz6upqaG8vBzbTi1P13WZM2cOixYtYt68eRx++OFtHr+oqIgLL7yQSZMm8eyzz1JVVdVid4wlS5Z06nwAS5YsIR6PM3Xq1K58BJJj8mFNWpbFddddx6JFi3jvvfe48847qa6ublEOLfkvF9aiCHT9WjTGcMcdd3D99de3Wa14MF+rpffJt/UXDAY588wzmTVrFk8//XSXPQfJvnxbi57hw4ezY8eOg75/yQ35tA7z/fvn9htKRbrI8uXLueWWW/jNb37DySefnPn4xIkTmTdvHslkMtPfvHLlysxcHIC7776bTz75hHnz5lFeXt7iuFdffTWnnHIKl156aeZjlmXh9/sZPnw4K1eubPH5NTU1HZ4P4LXXXmP69Okd9lxL/sqXNfnZZ5/x6aefMnPmTCA1E2DZsmX8x3/8R9c9DMmqXFmLIt2xFrds2cKSJUv45JNPmDt3LpAanm/bNosWLWLBggUH/LVaepd8WX933HEHZWVl3HjjjZn3eL+3Su+QL2tx3rx59OvXr0WL3Pr16xkxYkTXPhDJinxZh568//45S7thSgFJJBLm3HPPNc8888xer8ViMXPGGWeYuXPnmkgkYt5//30zdepU8/rrrxtjjFm6dKmZNm2a2blzZ5vH/t3vfmdOPfVUs3r1apNIJMxrr71mxo8fb9566602P7+j83kuvfRSc++99x7UfUvuyqc1+c4775hJkyaZFStWmGg0av7rv/7LXHDBBcZ13S55FpJdubQWm7vsssvM/fff3+ZrmzZtMmPGjDHr1q3r/I1KzuuutZhMJs3WrVtb/PWDH/zA3H333WbHjh1tXktnv1YbY8yYMWPM4sWLD+reJfvyaf394x//MFOmTDHvvPOOSSaTZtmyZea4444zf/7zn7vseUj25NNa/MMf/mCmT59uPvjgAxOPx83f/vY3c9RRR5mVK1d22fOQ7MindejJ9++fLWOMyXY4J73b0qVLufTSS9vc6ezFF18kHA5z++23s2rVKiorK/ne977HJZdcAsCtt97KggUL9kqep02bxuOPP47jODzyyCPMmzeP+vp6DjnkEK688kouuOCCfV7Pxx9/vM/zeWbNmsVFF13EFVdc0QVPQHJNvq3Jxx57jD/84Q+Ew2GmTZvGnXfeyZAhQ7roaUg25dJarKqq4pxzzgFSO63Zto3P52PYsGG89NJLPPTQQzz88MMYY0gkEgQCASzLYvbs2VxzzTVd/GSkp3XnWmxtzpw5DB8+nOuvv36f19Pe74sLFy7kpz/9KQDxeDyzFr/85S9z1113HfAzkOzJp/UHqUqdRx99lF27djFkyBAuuugirrzyygO9fckh+bQWjTE8/PDDPPvss+zcuZNDDjmEm2++WTuk9gL5tA49+f79s4IxEREREREREREpSJpgKiIiIiIiIiIiBUnBmIiIiIiIiIiIFCQFYyIiIiIiIiIiUpAUjImIiIiIiIiISEFSMCYiIiIiIiIiIgVJwZiIiIiIiIiIiBQkBWMiIiIiIiIiIlKQFIyJiIiIiIiIiEhBUjAmIiIiIiIiIiIFyZ/tCxARERGRtp155pls374d2079LLOyspITTjiBK6+8ktGjR3fqGE888QTf+ta38Pv1xz4RERGR1lQxJiIiIpLDbrvtNlauXMny5ct57LHH6N+/PxdeeCFvv/12h+/ds2cP9913H47j9MCVioiIiOQfBWMiIiIieSAQCHDEEUdwyy238K1vfYvbbrsNx3FYuXIll1xyCVOnTmXGjBncfvvtJBIJdu3axamnnooxhqlTpzJ//nwAnn/+eb785S8zefJkZs6cyZ/+9Kcs35mIiIhI9igYExEREckz3/72t9m8eTOrV6/mhz/8IdOnT+fdd9/l2Wef5fXXX+eZZ56hsrKS3//+9wAsXbqUr371q6xcuZKf/OQn3HTTTSxbtoz77ruPe++9l+XLl2f5jkRERESyQ8MmRERERPJMZWUlffv2ZfPmzSxcuJBgMIjP52PYsGFMmzaNVatWtfm++fPnc/rpp3PyyScDMHXqVM4991z+8pe/cOyxx/bkLYiIiIjkBAVjIiIiInkomUxi2zbvvPMODz74IJ9//jnJZJJkMsk555zT5ns2btzI22+/zdFHH535mDEmE5SJiIiIFBoFYyIiIiJ5ZsOGDUQiEQ4//HAuuOACbrnlFi666CKKioq46aabSCaTbb6vqKiIiy++mJ/+9Kc9fMUiIiIiuUkzxkRERETyzAMPPMCYMWP4+OOPCQaDXH755RQVFWGMYc2aNft838iRI1m7dm2Lj23btk27VoqIiEjBUjAmIiIikie2b9/OPffcw2uvvcbPf/5zhg8fTjQaZc2aNdTW1nL//fcTDAbZsWMHxhiKiooA+Oyzz4hEInzta19j+fLlPPfcc8TjcdasWcPXv/51XnrppSzfmYiIiEh2WMYYk+2LEBEREZG9nXnmmWzfvh3btjHGUFpayoknnsh1113H6NGjAbjrrrtYsGABxcXFzJ49m7FjxzJ79mxOOukkfvGLX3D55ZezatUqfvjDH3LFFVfwwgsvMHfuXKqqqhg0aBCXXXYZ3/72t7N7oyIiIiJZomBMREREREREREQKklopRURERERERESkICkYExERERERERGRgqRgTERERERERERECpKCMRERERERERERKUgKxkREREREREREpCApGBMRERERERERkYKkYExERERERERERAqSgjERERERERERESlICsZERERERERERKQgKRgTEREREREREZGCpGBMREREREREREQK0v8HcQEhSNkAVq4AAAAASUVORK5CYII=\n"
          },
          "metadata": {}
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1000x500 with 1 Axes>"
            ],
            "image/png": "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ST399NOqVKmSxo4dqwoVKqhIkSIaMWJErs9XtGhRde7cWatWrVJERIT27t2rU6dO3fbNeZaJEycqLS1Nvr6+yszMtHqzXqZMGVWvXl07duzQs88+q127dumpp56SdHOnrzp16mjXrl1q1aqV9uzZo169emU7/9/fsEk3g2BuPlH+e2jNejzp5qfX0s1AMnjwYP3555/y8fFRdHS0xo8ff8fz3s4ff/whd3d33Xfffbp06ZKefvppubi46NVXX9VDDz0kFxcXzZgxw+oanJYtW+r+++/XihUrNGzYMK1fv16NGzeWr6/vLR8nNTU12/It6eYyS1t3Xqtdu7Y8PT21Y8cOPfLII/r5558tyycrVqyocuXKKSYmRj4+Pjpy5Iiefvppqzri4+Ozhdf09HTLm9/U1FRdu3YtW1DNCpFnzpyx/F366quvlJaWJi8vL8u1greSNXPzz7+/Hh4eOQbnixcvymQy2XzNTZb7779foaGhWrFihbp3766VK1fqsccey3EmLjU1VRUrVsw27ubmlq22f+5od6cPInLi4eGhhx9+2Gp2zc/PT56enne9ZXexYsXUsmVLtWzZUtLN3+1Ro0Zp3rx5ateunR5++GGbzvf3fy+znuM//x5n9ebixYsFulEM4KgIRkAhtmzZMlWuXNly/cXfTZ48WcuXL7cEo8cff1zvvvuutm/fLicnJ124cEEdOnSwHO/p6akmTZooIiIi27lutaRIuvmGZtu2bXruueesgtY/d3ZydXXN8eLkvwemrDfmM2bMUPXq1bMdm/XG0VbJyclWISI6OlppaWl69913rS44v3DhQrZwcDvdunXTggUL9OOPP2rTpk0KCwuTj4/PHe/XokULdevWTX369NHcuXOtLoSXbi6N++qrr/THH3/oxIkTatSokeW2hg0bau3atdq3b5/S0tLydJvuf74BTUtLk/R/b9CaNm0qHx8frVu3TtWrV5ezs7Mee+yxu3689PR0bd26VaGhoTKZTNq9e7f++usvffzxx1bPK6uOLFnXPK1bt05DhgzRpk2b7hjQPDw8ctyGOTU1NVtQuJOsa8F+/PFH/fLLL0pPT8/Wox9++MES1P7+XDw9PeXj46OJEydmO2/WhwGenp4qVqzYLa8nKlu2rOXPFSpUUGRkpPr376/XXntNn3zyyS2DQtbzzApIWR588MFsmz9I0u+//y5fX18VK1ZMc+fO1UcffZTjeaWbH7y89dZb2cY7duyoV155Rd9//73i4uJy3AQmq7a86k9uVK5cOcdZlhs3blgCdPv27XXixIlbnmP+/PmqX7++MjIylJ6eni2wVapUSePGjVPHjh0VHx9vCUb/DDf//P22RdYMUn68RkBhRDACCqm0tDRt2LBBzz77bI6fRHbs2FFjxozRyZMnVbZsWZUrV05169ZVdHS0bty4obp161otgapTp44SEhJUqVIlq/MkJCTc9pP4a9euKTMz0yq0XL9+XWvWrLE6rlKlStqxY4fOnz9vCR/79u1TUlKS5fwBAQFydnbWiRMn1KpVK6vneu7cubv6n/+NGzc0YcIEOTs7W74gNeuT9b/X/NNPP+n333+3advrBx98UCEhIVqzZo22bt2a69mTxx9/XPXr11dERIRmzZqlkJAQq9mBRx55RJ9++qmWLl0qDw8Pq6WLjRo10uzZs7Vlyxara1fyQtbOalkOHDigUqVKydvbW9LNQPDkk09q/fr1Onz4sDp06HDb0Hwn7777rmXTACnnvhw/fly7d+/ONmvRrVs3zZ8/X3PnzpXJZFKLFi1u+1i1a9fWjz/+aDVDd/XqVe3bt8/qOedWWFiYNm3apO+++07Vq1e3vEbSzR6NHz9eFStWVJUqVSwzldLNv2fffPONypYta/Xa/f7775YlkXXq1NGnn36qy5cvq0aNGpZjTp8+LVdXV6v7NWnSRFWrVtWMGTPUu3dvzZ8/XwMHDsyx5hIlSsjNzU1//fWX1XizZs20evVqHTlyRNWqVZN0M7R+//33lteme/fuatu27S1fj5xm46SbHwK4ublp6tSpeuCBBxQSEpLjcbVr19b69et19epVy3K6zMxM/fTTTwoMDLzl496tRx55RB9++KHOnDljWVp46NAhpaamWr54dt68edm+r+rvypQpo/T0dDVr1kyhoaGaPn16tmOyduYsU6aMpJuh959h659bv9vizJkzcnV1tekDHcDIuMYIKKTWr1+vS5cu3fJNXatWreTs7Gx1kXp4eLi2b9+ub7/91rLpQpYBAwYoPj5e48eP16FDh/T7779r3rx5Cg8Pv+0WyKVKlVLlypW1YsUKxcfH6+DBg3rhhRcsb/T37Nmj1NRUtW3bVteuXdNbb72lI0eO6IcfftC4ceOsQpe3t7eefPJJvf/++1q1apWOHTumvXv3aujQoXr66actS7pu5erVqzpz5ozOnDmjEydO6Ntvv1WfPn20bds2zZgxw/JJe506dSTd3F3v+PHjio6O1ltvvaXmzZvr2LFjSkxMzPV3mXTv3t2yjLFZs2a5uk+WgQMHql69ehoxYoTVp9f16tVTiRIl9NVXXyk4ONjquq9atWpZbvv7tSt5YefOnVq6dKn+/PNPLV++XOvWrVPnzp2tjunatat+//13bd68Ode772VkZFj6curUKe3atUsRERFatGiRxowZYwmjAQEBKlKkiD799FMdO3ZMMTExGjJkiNq2bSuz2awDBw5YrpsrX768mjRpog8//FCdOnW64+swYMAAHT16VOPHj1dCQoIOHjyol19+WVevXrXaLj63wsLClJmZqWXLllmuL8rSsGFDXbp0SevXr882o9e7d29dunRJw4cPV1xcnI4dO6avvvpKnTp1UlRUlCSpefPmql69ukaMGGH5jrJvv/1WTz/9tMaMGZNjPfXr19egQYM0c+ZM7d2795Z1BwcHZ/surMcee0wPP/ywXnvtNf366686evSoXn/9dV27ds0SWu/mGiPp5vKy1q1b68iRI3r88cdvuTnGM888o6tXr2r48OGKj4/XkSNHNG7cOB09elT9+/e/5fPJyeeff642bdrcdov/Xr16qVSpUnrxxRd16NAh/fTTTxo1apR8fX0t/zbm5hojV1dXDRo0SGvWrNHIkSP1ww8/6Pjx4/rtt9/03//+V6NHj1ZwcLAlENaqVUvHjx/XV199pWPHjmnFihW3/ff1Tvbs2aMGDRrc1XJCwIgIRkAhtXz5ctWoUUNVq1bN8faSJUsqNDRUK1eutCzdaNOmjZKTk5Wamqo2bdpYHV+/fn19/PHHio+P11NPPaXw8HBt2rRJ//nPf+74afz06dPl4uKirl27aujQoWrVqpVGjx6tunXrauLEidq4caOCgoI0ceJE/fzzz+rSpYveeecdvf766ypVqpTVJ+Bjx45Vnz59NHv2bLVp00bPPfecPD099fnnn9/2wnJJ2rJli5o0aaImTZqoZcuWGjt2rMqXL6+VK1daPYe6detq+PDhWrduncLDw7V48WJFRkZa3gR27949V5sVSDevd3FyclKXLl1uuxtYTpycnDRjxgylpaVp9OjRlnFXV1cFBwfr/PnzVku0pJvLyBo0aKDz58/n6TI6SRo5cqS+//57dezYUZMnT1bHjh2zfSdTmTJlVLduXQUGBua43DEn+/fvt/Ql6zu1nJycFBUVpR49eliO8/X11aRJk/Tzzz9bln6OHTtWL7zwgh544AH16tVLf/75p+X4du3a6fr167naFS84OFgffvih9u/fr86dO6tnz55KS0vT4sWLb/l36HZ8fHz00EMP5dijBx54QNWqVcuxR5UqVdJnn32mtLQ09e7dW23bttXixYs1cuRIy4ymq6urFi5cqMDAQA0fPlytWrXSmDFj1LJlyxxnJbIMGTJEgYGBeuWVV7Itl8vSsmVL/fbbb1bXVRUpUkQff/yxqlSpov79+6tz5846d+6cPvvss1wtDb2TrCW7Oe1Gl+XBBx/UwoULdf78eT311FPq0qWL4uPjNXfu3GzB805SUlKyfcnuP9133336/PPPVapUKfXo0UP9+/dX+fLl9eWXX9o8C9q7d2/NmzdP58+f16uvvqo2bdqoW7du+uqrr9SvXz/Nnz/fEgifeeYZhYeHa8aMGerYsaP+97//Wf3dt8WpU6d04MAByzVNAO7MlMkejgDuEcnJyfLw8LB8up+RkaHQ0FC1a9fuX31PkT1t2rRJr7zyirZs2WJZLlOYnT59Wq1atdK0adOyheuCNmjQIGVmZt722hdYu3btmtq2bauQkBBNmjTJ3uXkm1atWmnz5s32LiNfTZgwQdu2bdOmTZv+1ZJWwEi4xgjAPSEhIUEdOnRQhw4dLDMzixYt0oULF/7V9+DYy9mzZ7Vv3z6NHTtW/fv3L/Sh6Pz58zp+/LjGjRungICAf7Xpwr+Rnp6uM2fOKCoqStu3b7daKoo7c3Fx0ZgxYzRkyBB17949X67fsbft27fL39/f3mXkq0OHDmnZsmV69913CUWADZgxAnDP+P777zVnzhwdPnxYTk5OqlatmgYPHqxHHnnE3qXZ7LHHHtP58+fVqVMnjRgxIk+v9bkXjR49WmvXrlWjRo00ceJEq80GClJsbKyeeeYZVa5cWaNGjVLTpk3tUoej++ijjxQVFaXly5dbbZmPe9/FixfVpUsXhYeHa+jQofYuB3AoBCMAAAAAhsfmCwAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAK7XbdZ87k/OV1hYGXl5uSk3P35ZK4t9A7x0XvHBN9c1z0znHRO8dU2PtWurTHHY+xazBKSkrShAkTtHfvXpUoUULt2rWzfOP53/Xr10979uyxGsvIyNCQIUP04osvFmTJdmcySc7OTjKZJPYTdCz0znHRO8dE3xwXvXNc9M4x0beb7BqMIiIi5O/vr+joaJ07d07PP/+8vL299eyzz1od9+mnn1r9fOHCBbVr106tWrUqyHIBAAAAFFJ2u8YoLi5Ohw4d0ogRI+Th4aHKlSurb9++ioqKuuN933vvPbVq1Up+fn4FUCkAAACAws5uM0b79++Xr6+vSpYsaRnz9/dXYmKiUlNT5e7unuP9/vjjD61atUrR0dF3fAyTKc/KvWdkPafC+NwKO3rnuOidY6JvjoveOS5655jo2012C0Zms1menp5WY1khKSUl5ZbBaN68eXriiSfk5eV12/N7ebnJ2bnwbrp3//13voAM9yZ657jonWOib46L3jkueueYjN43u15jlGnj1V1ms1mrV6/W119/fcdjk5MvFcrUazLd/KU9d+6ioS+Oc0T0znHRO8dE3xwXvXNc9M4xGaFv3t738K50Xl5eMpvNVmNms1kmk+mWs0FbtmxRlSpVVKFChVw9RmFtrHTzuRXm51eY0TvHRe8cE31zXPTOcdE7x2T0vtltrVlAQIBOnjyp5ORky1hcXJyqVasmNze3HO+zZcsWhYaGFlSJAAAAAAzCbsGoZs2aCgwMVGRkpFJTU5WQkKAFCxaoR48ekqQ2bdooNjbW6j4HDx5U+fLl7VEuAAAAgELMrrsTzJo1S3/99ZdCQ0PVu3dvderUST179pQkJSYmKi0tzer4M2fOyNvb2x6lAgAAACjE7Lr5go+Pj+bPn5/jbfHx8dnG9u3bl98lAQAAADCgwrufNQAAAADkEsEIAAAAgOERjAAAAAAYHsEIAAAAgOERjAAAAAAYHsEIAAAAgOHZdbtuAAAA5K8Gkd/Zu4R8s2f4I/YuAYUIM0YAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwCEYAAAAADI9gBAAAAMDwiti7gMKgQeR39i4hX+0Z/oi9SwAAADCcwvwe8158f8mMEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDY1c6AABwR4V5dyzp3twhC0DBYsYIAAAAgOERjAAAAAAYHkvpAAAFqjAvyWI5FgA4LrvOGCUlJWngwIEKCQlR8+bNNX36dN24cSPHYxMSEvTMM8+odu3aatq0qRYuXFiwxQIAAAAotOwajCIiIlSmTBlFR0drwYIFio6O1qJFi7Idd+XKFQ0YMEBNmzbVrl27NHv2bC1btkwJCQl2qBoAAABAYWO3YBQXF6dDhw5pxIgR8vDwUOXKldW3b19FRUVlO/brr7+Wu7u7BgwYoOLFi6tWrVpat26dqlataofKAQAAABQ2drvGaP/+/fL19VXJkiUtY/7+/kpMTFRqaqrc3d0t4z/++KOqV6+u119/XZs3b5a3t7cGDx6sDh063PYxTKZ8K99QeB3zRtbryOvpeOgdcovfEcdF7xwTfXNc92Lv7BaMzGazPD09rcayQlJKSopVMDp16pRiY2P19ttva+zYsdq4caNGjhypatWqqWbNmjme38vLTc7ObLqXF7y9PexdQqFy//28no6K3uFO+PfScdE7x0TfHNe92Du77kqXmZmZ6+P8/f0VHh4uSercubO+/PJLbdy48ZbBKDn50j2ZRB3R2bMX7V1CoWAy3Xxjfe7cReXyVx/3CHqH3OLfS8dF7xwTfXNcBd273AQxuwUjLy8vmc1mqzGz2SyTySQvLy+r8dKlS2c71tfXV2fOnLntY/AGJm/wOuatzExeU0dF73An/H44LnrnmOib47oXe2e3tWYBAQE6efKkkpOTLWNxcXGqVq2a3NzcrI6tWrWqDh8+bDXDlJSUJF9f3wKrFwAAAEDhZbdgVLNmTQUGBioyMlKpqalKSEjQggUL1KNHD0lSmzZtFBsbK0nq0KGDUlJSNHfuXF25ckXr1q3T/v3777j5AgAAAADkhl13J5g1a5b++usvhYaGqnfv3urUqZN69uwpSUpMTFRaWpokqUyZMvroo4+0ceNGNWjQQLNnz9acOXNUsWJFe5YPAAAAoJCw6+YLPj4+mj9/fo63xcfHW/0cHBys1atXF0RZAAAAAAyG/awBAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGF4RexcA2FODyO/sXUK+2jP8EXuXAAAA4BCYMQIAAABgeAQjAAAAAIZHMAIAAABgeAQjAAAAAIZHMAIAAABgeOxKB8AhFeYdBdlNEACAgseMEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMLwi9nzwpKQkTZgwQXv37lWJEiXUrl07DR8+XE5O1nlt9uzZ+uCDD1SkiHW527Ztk7e3d0GWDAAAAKAQsmswioiIkL+/v6Kjo3Xu3Dk9//zz8vb21rPPPpvt2I4dO2rq1Kl2qBIAAABAYWe3YBQXF6dDhw5pwYIF8vDwkIeHh/r27atFixblGIzuhsmUJ6cxPF5Hx0XvHBN9c1z0znHRO8dE3xzXvdg7uwWj/fv3y9fXVyVLlrSM+fv7KzExUampqXJ3d7c6Pj4+Xt27d9fhw4dVtmxZvf7662rSpMktz+/l5SZnZy6hygve3h72LgF3id45JvrmuOid46J3jom+Oa57sXd2C0Zms1menp5WY1khKSUlxSoY+fj4qEKFCho+fLgeeOABRUVFadCgQVqzZo0efPDBHM+fnHzpnkyijujs2Yv2LgF3id45JvrmuOid46J3jom+Oa6C7l1ugphdrzHKzMzM1XFdu3ZV165dLT/37dtX69ev15o1a/TSSy/d5vz/tkJIvI6OjN45JvrmuOid46J3jom+Oa57sXd2W2vm5eUls9lsNWY2m2UymeTl5XXH+/v6+uqvv/7Kp+oAAAAAGIndglFAQIBOnjyp5ORky1hcXJyqVasmNzc3q2M/+OADxcTEWI0lJCSoQoUKBVIrAAAAgMLNbsGoZs2aCgwMVGRkpFJTU5WQkKAFCxaoR48ekqQ2bdooNjZW0s2ZpAkTJujo0aO6evWqPv30U/3555/q3LmzvcoHAAAAUIjY9RqjWbNmacyYMQoNDZW7u7u6d++unj17SpISExOVlpYmSRo+fLikm9cWmc1mVatWTQsXLpSPj4/dagcAAABQeNg1GPn4+Gj+/Pk53hYfH2/5c9GiRfXGG2/ojTfeKKjSAAAAABgIX/QDAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMr4itd7h+/bq2bdumo0ePKj09PdvtL774Yp4UBgAAAAAFxeZg9MYbb2j9+vWqWrWqihUrZnWbyWQiGAEAAABwODYHo6+//lpLly7Vww8/nB/1AAAAAECBs/kaowceeEBVqlTJj1oAAAAAwC5sDkajRo3SzJkzdeXKlfyoBwAAAAAKXK6W0jVp0sTq50uXLmnx4sUqVapUtmO3b9+eN5UBAAAAQAHJVTAaPnx4ftcBAAAAAHaTq2DUuXNnRUVFKSwsTOXKlcvvmgAAAACgQOX6GqP//Oc/atGihdq1a6cpU6Zox44dOX6PEQAAAAA4mlxv171r1y7t379fMTExiomJUVRUlCSpQYMGCgsLU1hYGLvVAQAAAHBINn2Pkb+/v/z9/TVgwAClp6frxx9/1K5du7Rx40ZFRkbqgQce0ObNm/OrVgAAAADIFzZv153F1dVV5cqVU9myZeXj46P77rtPFy5cyMvaAAAAAKBA2DRjlJycrJiYGO3cuVMxMTEym82qV6+eQkJC1K9fP/n7++dXnQAAAACQb3IdjDp06KCkpCTVqVNHdevW1bRp01SnTh0VKWJTtgIAAACAe06ul9KVK1dOJpNJSUlJOnnypE6dOqXz58/nZ20AAAAAUCByPd0zd+5cXb9+XXv37tXOnTv13//+V6NGjVKVKlXUsGFDNWrUSMHBwXJ3d8/PegEAAAAgz9m0Ds7Z2Vl169ZV3bp19eKLLyotLU2xsbHas2ePpk6dqhMnTmjfvn35VSsAAAAA5Iu7vkDo1KlT2r59u2JiYvTDDz8oOTlZtWvXzsvaAAAAAKBA5DoYXbp0Sbt379bOnTu1Y8cO/f777ypTpoyaNGmi0aNHq3HjxvLw8MjPWgEAAAAgX+Q6GIWEhFiW0nXt2lVhYWF66KGH8rM2AAAAACgQuQ5G77//vkJCQnTjxg25ubnleMwff/yhSpUq5VlxAAAAAFAQcr1dd7NmzVS8eHH17NlTf/31V7bblyxZok6dOuVlbQAAAABQIHIdjLKEhoaqa9euio+PlySdPn1a/fr104cffqgZM2bkeYEAAAAAkN9s3pXutdde00MPPaS+ffuqe/fuWrJkiRo1aqS1a9eqVKlS+VEjAAAAAOSru9quu3PnzqpcubJefPFFtWjRQlOmTMnrugAAAACgwOQqGA0fPjzH8YoVK2rt2rW6fPmynJ2dJUmRkZF5Vx0AAAAAFIBcBSNXV9ccxytXrqzKlSvnZT0AAAAAUOByFYxYKgcAAACgMLN5VzoAAAAAKGzsGoySkpI0cOBAhYSEqHnz5po+fbpu3Lhx2/ucPn1aQUFBmj17dgFVCQAAAKCwu6td6fJKRESE/P39FR0drXPnzun555+Xt7e3nn322VveZ+LEiZaNHgAAAAAgL9g8Y7R06VJdvHjxXz9wXFycDh06pBEjRsjDw0OVK1dW3759FRUVdcv7fPvttzpy5IiaNWv2rx8fAAAAALLYPGM0b948vf3222ratKnCw8PVrFmzW+5adzv79++Xr6+vSpYsaRnz9/dXYmKiUlNT5e7ubnX8lStX9NZbb2nSpElatWpVrh7DZLK5LOSA19Fx0TvHRN8cF71zXPTOMdE3x3Uv9s7mYLR582YdPHhQmzdv1uzZszV69Gg99thjCg8PV0hISK7PYzab5enpaTWWFZJSUlKyBaM5c+aoTp06atiwYa6CkZeXm5yd2VsiL3h7e9i7BNwleueY6JvjoneOi945JvrmuO7F3t3VNUYPP/ywHn74YQ0dOlR//PGH1q1bpxdffFElSpTQE088oV69eun++++/43kyMzNz9XhHjhzR0qVLtXbt2lzXmJx86Z5Moo7o7Nl/v3QS9kHvHBN9c1z0znHRO8dE3xxXQfcuN0HsX22+EBsbq3Xr1mnTpk0qVqyY2rdvrxMnTqh9+/aaPn26wsLCbnlfLy8vmc1mqzGz2SyTySQvLy/LWGZmpsaPH6+IiAiVLl3apvpymbtwB7yOjoveOSb65rjoneOid46Jvjmue7F3Ngej3377TWvXrtW6deuUkpKiFi1aaNq0aWrcuLGcnG4uXduyZYvGjx+vLVu23PI8AQEBOnnypJKTky1BKC4uTtWqVZObm5vluBMnTmjPnj367bffNGvWLElSWlqanJyctHXrVq1cudLWpwAAAAAAVmwORh06dFCDBg304osvqnXr1lYhJkuLFi00Y8aM256nZs2aCgwMVGRkpF5//XWdPn1aCxYsUL9+/SRJbdq00cSJExUUFKRvv/3W6r5TpkyRj4+PBgwYYGv5AAAAAJCNzcFo69atKlu27B2P+/rrr+94zKxZszRmzBiFhobK3d1d3bt3V8+ePSVJiYmJSktLk7Ozs3x8fKzuV7x4cbm7u9u8tA4AAAAAcpKrYDR8+PBcnzAyMjLXx/r4+Gj+/Pk53hYfH3/L+02dOjXXjwEAAAAAd5KrYHQ331MEAAAAAI4iV8FoypQp+V0HAAAAANhNroLRrFmzNHToUEnSu+++e9tjX3nllX9fFQAAAAAUoFwFo71791r+/PPPP9/yOBPfqAoAAADAAeUqGH3yySeWP3/22We3PG7btm3/viIAAAAAKGA2b9ctSSkpKfrtt9+Unp5uGTt9+rQmTpx42xklAAAAALgX2RyMNm/erBEjRujq1asymUzKzMyUJHl6eqpr1655XiAAAAAA5DcnW+/w3nvvacKECfr111/l4uKiAwcO6KuvvlLDhg311FNP5UeNAAAAAJCvbA5GJ06cUKdOneTq6iqTySQnJyfVqlVLQ4cO1euvv54fNQIAAABAvrI5GHl7eyshIUGSVKpUKR06dEiSVL58ef322295Wx0AAAAAFACbrzHq1auXunTpoh07dqh169YaNGiQWrRooUOHDsnPzy8/agQAAACAfGVzMOrbt68CAgLk7u6uV199VcWLF1dcXJyqVq2qQYMG5UeNAAAAAJCv7mq77vr169+8c5Eieumll/KyHgAAAAAocDYFo8uXL+uTTz7Rxo0bdfz4cTk5OenBBx9UeHi4evXqpSJF7ipnAQAAAIBd5TrJXL16Vb169VJqaqq6deumKlWq6Pr169q/f7/mzJmjzZs369NPP5Wrq2t+1gsAAAAAeS7XwWjhwoVycXHR6tWrVbx4ccv4Y489pj59+ui5557T/PnzNWTIkHwpFAAAAADyS6636/7mm2/0yiuvWIWiLF5eXho9erTWrl2bp8UBAAAAQEHIdTBKTEyUv7//LW+vU6eOTp48mSdFAQAAAEBBynUwunHjhtzd3W95u8lkypOCAAAAAKCg2bSN3LVr15SZmZlftQAAAACAXdi0K12tWrXysxYAAAAAsItcB6PFixfnZx0AAAAAYDe5DkbBwcH5WQcAAAAA2E2uN18AAAAAgMKKYAQAAADA8AhGAAAAAAzvXwWjlJSUvKoDAAAAAOzG5mB06dIljR07VnXq1FFYWJgkyWw26/nnn1dycnKeFwgAAAAA+c3mYPTWW2/p2LFj+vjjj+XkdPPuLi4ucnd318SJE/O8QAAAAADIb7nerjvL//73P3399dfy8vKSyWSSJLm5uWncuHFq3bp1nhcIAAAAAPnN5hkjk8kkd3f3bOPXr1/X1atX86QoAAAAAChINgejoKAgTZs2TVeuXLGMJSUl6c033+RLYAEAAAA4JJuD0ZgxYxQbG6v69evr6tWrqlevnlq2bKmUlBSNGzcuP2oEAAAAgHxl8zVG5cqV06pVq/Trr7/q+PHjKlq0qCpWrKiHHnooP+oDAAAAgHxnczA6ceKEJMnb21ve3t5W405OTvL29laRIjafFgAAAADsxuYE8+ijj1p2o8uJk5OTGjdurIkTJ6pMmTL/qjgAAAAAKAg2B6OPPvpIM2fOVPfu3RUYGCiTyaS4uDgtW7ZMgwYNUvHixbVw4UK9/fbbev/99/OjZgAAAADIUzYHo/fee0/vvfeeKlWqZBmrUaOG6tevrzfffFNffPGF/P399dhjj+VpoQAAAACQX2zele7o0aPy8vLKNl66dGkdOHDA8vONGzf+XWUAAAAAUEBsnjGqU6eOXnjhBfXr10/lypWTi4uLkpKStHDhQlWrVk0ZGRmKiIhQo0aN8qNeAAAAAMhzd7WU7o033tCwYcN07do1SZKzs7Pq16+vmTNnqkiRIvL19dVrr72W58UCAAAAQH6wORiVKlVKH374oTIzM2U2m5WZman77rtPTk5OOnjwoHx9fTVp0qT8qBUAAAAA8sVdfeFQZmamTpw4ofT0dEnS+fPndfr0aQ0ePFg//fRTnhYIAAAAAPnN5mAUGxuroUOHKiUlJdttLVu2tOlcSUlJmjBhgvbu3asSJUqoXbt2Gj58uJycrPeEyMzM1Jw5c7R8+XKZzWaVK1dOzz33nDp16mRr+QAAAACQjc3BaPLkyerVq5fatWunDh06aMOGDdq3b582bNigMWPG2HSuiIgI+fv7Kzo6WufOndPzzz8vb29vPfvss1bHLVq0SKtWrdInn3yiSpUqafPmzXr55ZdVvXp11axZ09anAAAAAABWbN6uOzExUYMHD1aVKlVkMplUoUIFtW3bVv3799fIkSNzfZ64uDgdOnRII0aMkIeHhypXrqy+ffsqKioq27E1atRQZGSkHnzwQTk7O6tNmzby8PDQkSNHbC0fAAAAALKxecaoZMmSOnPmjB544AF5enrq2LFjqlChgvz9/fXLL7/k+jz79++Xr6+vSpYsaRnz9/dXYmKiUlNT5e7ubhlv2LCh5c9XrlzRsmXL5OTkdMctwU2m3D8v3Bqvo+Oid46Jvjkueue46J1jom+O617snc3B6PHHH9cTTzyhr7/+WmFhYYqIiFCHDh0UFxen8uXL5/o8ZrNZnp6eVmNZISklJcUqGGUZPXq0li1bpnLlymnOnDkqXbr0Lc/v5eUmZ2ebJ8SQA29vD3uXgLtE7xwTfXNc9M5x0TvHRN8c173YO5uD0YgRI1StWjW5ubnpzTff1IQJE/TVV1/J19dX06ZNs+lcmZmZNh0/ceJEjR49WuvXr9egQYO0aNGiW15jlJx86Z5Moo7o7NmL9i4Bd4neOSb65rjoneOid46Jvjmugu5dboKYzcFo7969lt3g3N3dNX36dJsLkyQvLy+ZzWarMbPZLJPJJC8vr1ver1ixYnriiSe0YcMGLVu2TGPHjr3lsTbmLtwCr6PjoneOib45LnrnuOidY6Jvjute7J3Na8369+9v+f6ifyMgIEAnT55UcnKyZSwuLs4yG/V3gwYN0pIlS6zGTCaTihS5q69hAgAAAAArNgejiIgIvfPOO0pISNDly5eVnp5u9V9u1axZU4GBgYqMjFRqaqoSEhK0YMEC9ejRQ5LUpk0bxcbGSpLq1q2refPm6cCBA8rIyNDWrVsVExOj5s2b21o+AAAAAGRj85TLe++9p4yMDH3xxRc53n7w4MFcn2vWrFkaM2aMQkND5e7uru7du6tnz56Sbm4LnpaWJunmLNW1a9c0cOBAXbx4UeXLl9fEiRPvuCsdAAAAAOSGzcHoo48+yrMH9/Hx0fz583O8LT4+3vJnZ2dnDRkyREOGDMmzxwYAAACALDYHo+DgYMufU1JSVKpUqTwtCAAAAAAKms3XGF26dEljx45VnTp1FBYWJunmbnLPP/+81UYKAAAAAOAobA5Gb731lo4dO6aPP/5YTk437+7i4iJ3d3dNnDgxzwsEAAAAgPxm81K6//3vf/r666/l5eUl0///BlU3NzeNGzdOrVu3zvMCAQAAACC/2TxjZDKZ5O7unm38+vXrunr1ap4UBQAAAAAFyeZgFBQUpGnTpunKlSuWsaSkJL355ptWGzMAAAAAgKOwORiNGTNGsbGxql+/vq5evap69eqpZcuWMpvNGjduXH7UCAAAAAD5yuZrjMqVK6dVq1bp119/1fHjx1W0aFFVrFhRDz30UH7UBwAAAAD5zuZg9Nxzz6l9+/Zq2bKlatWqlR81AQAAAECBsnkpXaVKlTRr1iw1btxYQ4YM0YYNG3T58uX8qA0AAAAACoTNwWj06NHaunWrvvjiCz300EOaM2eOGjdurJdeeknR0dH5USMAAAAA5Cubg1GWgIAAvfTSS1q/fr0WLVqks2fPKiIiIi9rAwAAAIACYfM1RllOnjyp6OhoRUdH68cff5S/v79ee+21vKwNAAAAAAqEzcFozpw52rJliw4dOqSAgAC1bdtWU6ZMUbly5fKjPgAAAADIdzYHo2+//VaPP/643n///Wxh6MKFC/L09Myz4gAAAACgINgcjL766qtsYzExMVq6dKm2bNmivXv35klhAAAAAFBQ7voaoxMnTmjFihVauXKlzpw5o+bNm2v27Nl5WRsAAAAAFAibglF6erqio6O1dOlS/fDDD6pdu7b++usvLV26VDVq1MivGgEAAAAgX+U6GL399ttat26d7rvvPoWHh+utt95ShQoVFBQUJDc3t/ysEQAAAADyVa6D0ZIlS9S+fXsNGzZMFStWzM+aAAAAAKBA5foLXj/++GNdv35d4eHh6t69u/773//KbDbnY2kAAAAAUDByPWPUpEkTNWnSRCkpKVq9erW++OILTZo0STdu3NCuXbtUtmxZFSly13s5AAAAAIDd5HrGKEupUqXUt29frV27Vp9//rk6d+6sKVOm6JFHHtHUqVPzo0YAAAAAyFf/aoqnTp06qlOnjt58802tX79ey5cvz6u6AAAAAKDA5MnatxIlSqhr167q2rVrXpwOAAAAAAqUzUvpAAAAAKCwIRgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDy7BqOkpCQNHDhQISEhat68uaZPn64bN27keOx///tftW7dWkFBQerYsaOio6MLuFoAAAAAhZVdg1FERITKlCmj6OhoLViwQNHR0Vq0aFG247755htFRkZq8uTJ+uGHH/T000/rpZde0rFjx+xQNQAAAIDCxm7BKC4uTocOHdKIESPk4eGhypUrq2/fvoqKisp27JUrV/TKK6+oXr16cnFxUdeuXeXm5qZffvml4AsHAAAAUOgUsdcD79+/X76+vipZsqRlzN/fX4mJiUpNTZW7u7tlvGPHjlb3vXDhgi5duqQyZcrc9jFMpryt2ah4HR0XvXNM9M1x0TvHRe8cE31zXPdi7+wWjMxmszw9Pa3GskJSSkqKVTD6u8zMTI0ePVq1a9dWcHDwLc/v5eUmZ2f2lsgL3t4e9i4Bd4neOSb65rjoneOid46Jvjmue7F3dgtG0s2QY4tr165p1KhROnLkiBYvXnzbY5OTL92TSdQRnT170d4l4C7RO8dE3xwXvXNc9M4x0TfHVdC9y00Qs1sw8vLyktlsthozm80ymUzy8vLKdvyVK1c0ePBgXb58WUuWLFGpUqXu+Bg25i7cAq+j46J3jom+OS5657jonWOib47rXuyd3daaBQQE6OTJk0pOTraMxcXFqVq1anJzc7M6NjMzUy+//LKKFCmihQsX5ioUAQAAAEBu2S0Y1axZU4GBgYqMjFRqaqoSEhK0YMEC9ejRQ5LUpk0bxcbGSpLWrl2rI0eOaObMmSpatKi9SgYAAABQSNn1GqNZs2ZpzJgxCg0Nlbu7u7p3766ePXtKkhITE5WWliZJWr58uZKSkrJtttCxY0dNnDixwOsGAAAAULjYNRj5+Pho/vz5Od4WHx9v+XNOX/oKAAAAAHmF/awBAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDhEYwAAAAAGB7BCAAAAIDh2TUYJSUlaeDAgQoJCVHz5s01ffp03bhxI8djL126pBEjRsjPz08JCQkFXCkAAACAwsyuwSgiIkJlypRRdHS0FixYoOjoaC1atCjbcadPn1aXLl3k7OxshyoBAAAAFHZF7PXAcXFxOnTokBYsWCAPDw95eHiob9++WrRokZ599lmrY1NSUvTqq6+qRo0aWrVqVa4fw2TK46INitfRcdE7x0TfHBe9c1z0zjHRN8d1L/bObsFo//798vX1VcmSJS1j/v7+SkxMVGpqqtzd3S3jNWrUUI0aNXT8+PFcn9/Ly03OzlxClRe8vT3sXQLuEr1zTPTNcdE7x0XvHBN9c1z3Yu/sFozMZrM8PT2txrJCUkpKilUwuhvJyZfuySTqiM6evWjvEnCX6J1jom+Oi945LnrnmOib4yro3uUmiNktGElSZmZmPp8/X09vGLyOjoveOSb65rjoneOid46Jvjmue7F3dltr5uXlJbPZbDVmNptlMpnk5eVln6IAAAAAGJLdglFAQIBOnjyp5ORky1hcXJyqVasmNzc3e5UFAAAAwIDsFoxq1qypwMBARUZGKjU1VQkJCVqwYIF69OghSWrTpo1iY2PtVR4AAAAAA7Hrtm2zZs3SX3/9pdDQUPXu3VudOnVSz549JUmJiYlKS0uTJH3wwQcKDAxUmzZtJEkdO3ZUYGCgPvjgA7vVDgAAAKDwsOvmCz4+Ppo/f36Ot8XHx1v+PHjwYA0ePLigygIAAABgMHzRDwAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDIxgBAAAAMDyCEQAAAADDs2swSkpK0sCBAxUSEqLmzZtr+vTpunHjRo7HLl68WK1bt1bdunXVo0cP7du3r4CrBQAAAFBY2TUYRUREqEyZMoqOjtaCBQsUHR2tRYsWZTtu69atmj17tqZNm6adO3eqefPmGjRokNLS0uxQNQAAAIDCxm7BKC4uTocOHdKIESPk4eGhypUrq2/fvoqKisp2bFRUlLp06aLatWurWLFiGjBggCRp27ZtBV02AAAAgEKoiL0eeP/+/fL19VXJkiUtY/7+/kpMTFRqaqrc3d2tjm3Xrp3lZycnJz388MOKi4tT+/btb/kYJlP+1G40vI6Oi945JvrmuOid46J3jom+Oa57sXd2C0Zms1menp5WY1khKSUlxSoYmc1mqwCVdWxKSsotz1+6tEceVnt7v0+9dTjDvY3eOS5657jonWOib46L3jkuelew7HqNUWZmZr4cCwAAAAC2sFsw8vLyktlsthozm80ymUzy8vKyGi9VqlSOx/7zOAAAAAC4G3YLRgEBATp58qSSk5MtY3FxcapWrZrc3NyyHbt//37Lz9evX9eBAwdUu3btAqsXAAAAQOFlt2BUs2ZNBQYGKjIyUqmpqUpISNCCBQvUo0cPSVKbNm0UGxsrSerRo4dWrVqlX375RZcvX9aHH34oV1dXNWvWzF7lAwAAAChE7Lb5giTNmjVLY8aMUWhoqNzd3dW9e3f17NlTkpSYmGj5nqJHHnlEr7zyil566SWdO3dOgYGBmjdvnooVK2bP8gEAAAAUEqZMdjVwGElJSZowYYL27t2rEiVKqF27dho+fLicnOy6hwZy4fvvv9fIkSMVEhKi//znP/YuB7mUlJSkyZMnKzY2Vs7OznrkkUf0xhtvZNtRE/eeQ4cOacqUKdq3b5+KFi2q4OBgvfnmmypdurS9S4MNJk+erEWLFik+Pt7epeAO/Pz85OLiItPf9mDu1q2bxowZY8eqkFsffvihlixZotTUVNWpU0cTJ05U+fLl7V1WgeMdtQOJiIhQmTJlFB0drQULFig6OlqLFi2yd1m4g/nz52vixImqVKmSvUuBjQYNGiRPT09t3bpVK1as0G+//aZ33nnH3mXhDtLT09WvXz8FBwcrJiZG69at07lz5zR+/Hh7lwYbHDx4UKtXr7Z3GbDBxo0bFRcXZ/mPUOQYlixZojVr1mjx4sXavn27qlWrpoULF9q7LLsgGDmIuLg4HTp0SCNGjJCHh4cqV66svn37Kioqyt6l4Q6KFi2qZcuWEYwczIULFxQQEKDhw4fLzc1NPj4+6ty5s+XaR9y7Ll++rJdfflnPP/+8XF1d5eXlpVatWum3336zd2nIpRs3bmjcuHHq27evvUsBCr1PP/1UL7/8sh588EG5u7tr9OjRGj16tL3LsguCkYPYv3+/fH19rb7o1t/fX4mJiUpNTbVjZbiT3r17y8Oj4L5wGHnD09NTU6ZMkbe3t2Xs5MmTeuCBB+xYFXKjZMmS6tq1q4oUuXkZ7dGjR7Vy5Uq1bdvWzpUht7788ksVLVpU4eHh9i4FNoiMjFSzZs1Uv359jRkzRpcuXbJ3SbiD06dP6/jx4zp//rzatWunkJAQDR061GrXaCMhGDkIs9mc7bqGrJCUkpJij5IAQ4mLi9Pnn3+uF154wd6lIJeSkpIUEBCgdu3aKTAwUEOHDrV3SciFs2fPavbs2Ro3bpy9S4EN6tSpo8aNG2vTpk2KiorSL7/8ogkTJti7LNzBqVOnJN1cBrlgwQKtXr1ap06dYsYI9z72yQDs48cff1T//v01fPhwNW7c2N7lIJd8fX0VFxenjRs36vfff9drr71m75KQC1OmTFGXLl1UrVo1e5cCG0RFRalr165ydXVV1apVNWLECK1bt07p6en2Lg23kfXecsCAASpTpox8fHwUERGhrVu36urVq3auruARjByEl5eXzGaz1ZjZbJbJZJKXl5d9igIMYOvWrRo4cKDeeOMN9e7d297lwEYmk0mVK1fWyy+/rHXr1hl2eYijiImJ0c8//6whQ4bYuxT8S+XLl9f169d17tw5e5eC28haLv73VUm+vr7KzMw0ZO8IRg4iICBAJ0+etPqfelxcnKpVqyY3Nzc7VgYUXj/99JNGjhypmTNnqlOnTvYuB7kUExOj1q1b68aNG5axrK81cHFxsVdZyIU1a9bo3Llzat68uUJCQtSlSxdJUkhIiNavX2/n6nArBw4c0NSpU63GEhIS5OrqynWZ9zgfHx+5u7vr4MGDlrGkpCS5uLgYsncEIwdRs2ZNBQYGKjIyUqmpqUpISNCCBQvUo0cPe5cGFEoZGRkaPXq0RowYoSZNmti7HNggICBAqampmj59ui5fvqzk5GTNnj1b9evXZyOUe9yoUaP0zTffaPXq1Vq9erXmzZsnSVq9erUeffRRO1eHW7n//vsVFRWlefPmKT09XYmJiZo5c6aeeuopOTs727s83EaRIkX05JNPau7cufrjjz907tw5zZkzR+Hh4ZYNbIyEL3h1IKdOndKYMWP0ww8/yN3dXd27d9eLL75o9WVquPcEBgZKuvlGW5LlH5q4uDi71YQ7i42NVa9eveTq6prtto0bN8rX19cOVSG34uPjNXHiRP36668qUaKEGjZsqFGjRqlMmTL2Lg02OH78uFq0aMEXvDqAPXv2KDIyUvHx8XJ1dVXnzp318ssvq2jRovYuDXeQnp6uKVOmaP369bp27Zpat26tMWPGGHJFEsEIAAAAgOGxlA4AAACA4RGMAAAAABgewQgAAACA4RGMAAAAABgewQgAAACA4RGMAAAAABgewQgAAACA4RGMAAAAABgewQgAUOikpaWpd+/eql27tn788Ud7l6NRo0bp5ZdftncZAIDbIBgBAP61Rx99VP7+/goMDFRgYKCaN2+uUaNG6ciRI3apZ8eOHfr555+1bds21atXz+q2oUOHatiwYVZjycnJqlGjhhYsWGA1vmXLFgUEBCg1NTXfawYA2BfBCACQJ0aPHq24uDj99NNP+vjjj1WqVCk98cQTiomJKfBaUlNT5enpKS8vr2y3hYWFadeuXbpx44ZlbNeuXSpevLh27txpdWxMTIyCgoLk7u6e7zUDAOyLYAQAyFMuLi6qWrWqRo4cqWeeeUajR4/W9evXJUlxcXHq2bOn6tevr8aNG2vcuHG6du2aLl++rLp162rr1q1W5+rTp4/efffdHB8nOjpaHTp0UJ06dfToo49q8eLFkqSlS5dq9OjROnv2rAIDA7Vnzx6r+4WFhclsNmv//v2WsZ07d6pz586KjY3VtWvXrMbDwsIkSUlJSRo0aJBCQkLUoEEDvfbaa1YzSTExMXrqqacUFBSksLAwzZkz55av0bRp0xQeHs5MFADcQwhGAIB807dvXx0/ftwSQl5++WU1bNhQu3fv1rJly7Rt2zZ9+eWXKl68uFq3bq21a9da7puSkqI9e/aoQ4cO2c576NAhDRs2TEOHDtWePXs0adIkRUZG6ttvv1XXrl319ttvy9vbW3FxcWrQoIHVfX18fPTQQw9ZzQ7FxMSoXbt2KlWqlH755RdJ0unTp5WQkKCwsDBlZmZq8ODBKlu2rP73v/9p48aNOn36tN555x1J0qlTpzR48GD16NFDsbGx+vjjj/Xll19aPZ8sK1eu1Nq1azV//nxmogDgHkIwAgDkG29vb3l6eur48eOSpFWrVmnQoEFydnZWuXLl1KBBA+3bt0+S1LFjR23dutUyi7JlyxZVr15d1apVy3be5cuXq1GjRmrZsqVcXFzUqFEjNWvWTBs2bMhVXWFhYdqxY4ck6c8//9S5c+dUq1YtNWzY0BKYYmJiVLp0adWoUUNxcXH67bff9Oqrr6p48eK6//77FRERoTVr1igzM1Pr1q3TQw89pE6dOsnZ2Vl+fn7q3r27Vq9ebfW4P/30k6ZOnap58+bJx8fn7l5UAEC+KGLvAgAAhVtGRoacnG5+Drdr1y7NmTNHv//+uzIyMpSRkaE2bdpIkkJCQuTl5aXo6Gh16tRJmzdvVnh4eI7nPH78uKpWrWo1VqlSJf3000+5qiksLEyfffaZLl++rJ07d6pevXpydXVVo0aNtGTJEg0bNkw7d+5UkyZNZDKZdOzYMV2/fl0hISFW57l+/bpSUlL0559/Ki4uToGBgZbbMjMzVaVKFcvPJ0+e1Isvvqju3bvr4YcfzlWdAICCw4wRACDf/PHHH0pLS9ODDz6ohIQEDRs2TJ07d1ZMTIzi4uL0+OOPW441mUzq0KGD1q5dq9TUVO3evdvq9r9LT0/PcdxkMuWqrvr168vFxUV79uzRrl271KhRI0lSw4YNFRcXp9TUVO3atctyfVHRokVVokQJxcXFWf134MABeXl5qVixYmratKnVbfv27bNaSvfrr78qLCxMS5Ys0alTp3JVJwCg4BCMAAD5Zvbs2apevbqqV6+ugwcPytXVVb1791axYsWUmZmpgwcPWh3fsWNH7d69WytWrFDt2rVVpkyZHM9bsWJFHT161Grs6NGjqlChQq7qcnV1VXBwsPbs2aPY2FhLMCpdurQqVaqkVatW6cyZMwoNDbU8Xlpamo4dO2Y5R2pqqlJSUiy3Hz58WJmZmZbbz5w5YxXgWrZsqXfeeUeNGzfW66+/bnUsAMD+CEYAgDx3+vRpTZkyRVu2bNGkSZMkSb6+vrpy5YoOHjyo8+fPa/r06XJ1ddVff/1lCQkPPvigHn74Yc2cOfOWy+gkqUOHDtqxY4e2bdumjIwMff/99/rf//6nTp065brGsLAwff3117p27ZrV0raGDRtq0aJFCgwM1H333SdJql69uoKCgjRp0iQlJyfrwoULGjdunF577TVJUvv27WU2m/XBBx/oypUrOnbsmPr166dFixZZzuvs7CxJGj9+vA4fPqwlS5bkulYAQP4jGAEA8sTEiRMVGBiogIAAdejQQadPn9bSpUtVq1YtSVJQUJB69eqlp59+Wu3bt5evr6/eeOMNHT58WC+//LLlPJ06dVJ6erpat259y8fKCimRkZFq0KCBpk2bphkzZig4ODjX9YaFhenYsWMKDg62XAMlSY0aNdKff/5pWUaXJTIyUpmZmWrRooVatWql69eva+rUqZKkUqVK6YMPPtCWLVvUoEEDPf3002revLn69euX7XG9vLw0YcIEzZgxQ4mJibmuFwCQv0yZzOUDAO4hs2bN0rFjxzR9+nR7lwIAMBB2pQMA3DN++eUXffbZZ/rss8/sXQoAwGAIRgCAe0L//v0VHx+vkSNHqkaNGvYuBwBgMCylAwAAAGB4bL4AAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAMj2AEAAAAwPAIRgAAAAAM7/8BJ+jfcN+eG/cAAAAASUVORK5CYII=\n"
          },
          "metadata": {}
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1000x500 with 1 Axes>"
            ],
            "image/png": "iVBORw0KGgoAAAANSUhEUgAAA0YAAAHPCAYAAAB3BMohAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAARvRJREFUeJzt3Xt8z/X///H7eyexzZizERUWNrYZY4YiyWkORaJQqSQWbQ6FqJRy6JPwUSpKqUSOI4eZDhqFojktnznEHHLYGxuZsd8fvnv/eje0N3u/X7PX7Xq57HLxfr1e7/fr8Xx4j933fL2eb0tOTk6OAAAAAMDE3IwuAAAAAACMRjACAAAAYHoEIwAAAACmRzACAAAAYHoEIwAAAACmRzACAAAAYHoEIwAAAACmRzACAAAAYHoEIwAAAACmRzACgJs0bdo0BQYGavDgwUaXYoiWLVsqMDDQ9hUSEqK2bdvqlVde0b59+27oNR977DF1797d9jgwMFCTJk264Rp/+uknBQYG6vvvv7/q/u7du6tjx455tv/1118KDg5W79698+w7fPiwAgMDNXXqVB06dEiBgYFauHBhgdZ1Mx577DFbfdfSqVOnG6r7RrVs2VIjRoxwybkAwFEEIwC4CTk5OVq4cKECAwO1du1aWa1Wo0syRKtWrbR+/XqtX79eS5Ys0eDBg5WamqpOnTppxYoVDr/e1KlTNXPmTCdUenVRUVH6/fffdfz4cbvtmzZt0sWLF/Xrr7/qr7/+stuXlJQkSWrWrJnL6nRUiRIltGjRIuXk5OTZt3v3bv3xxx9OO3dWVpaCgoJ06NAhp50DAAoSwQgAbkJSUpLS0tL0xhtvyGKxaNmyZUaXZIhixYqpXLlyKleunKpVq6Y2bdrok08+UefOnTVs2DClpqY69HqlSpVSqVKlnFPsVeSGmx9//NFue1JSkho2bChJ2rx5s92+DRs2qFSpUqpXr55rirwBDRs21OHDh7Vx48Y8+xYtWmQbmzMkJyfr4sWLTnt9AChoBCMAuAnz589XaGiogoKC1Lp1a3399de2fTk5Obr33nsVGxub53kvv/yyIiIibD84fv/993r00UfVqFEjhYWF6amnnrILE7mzUt99951atWqlBx98UJKUnZ2tKVOmqFWrVqpbt66aNm2qmJiYPL+lT0hIUNu2bRUcHKwOHTrou+++05NPPqnHHnvMdkxWVpamTJmi9u3bq169emrRooUmTZqkrKysG+qNxWLR8OHDVbx4cc2ePdu2fd++fRo0aJAaNWpk69uMGTN0+fJl2zH/vJQu1++//37NS7/atm3r0OWMCQkJqlOnjubNm6d69erJz8/PNguUKykpSY0aNdLdd99tty8nJ0cbN25UZGSk3Nz+/3+lly5d0qRJk9S4cWMFBwfrySef1LFjx/61lrNnz+qFF15QWFiYwsLCNHToUJ07d04XL15UVFTUVS8/e/nll9WsWTNdunTpmq/r7++v0NDQPP3Kzs7WsmXL1LJly6vWMmbMGEVFRSkoKEgtWrTQuHHjdO7cOdsxjz32mAYMGKCVK1eqXbt2qlevnu19JV15v/bs2VPSldnEv7/PJGnJkiVq3bq1goKC1L59e/3yyy//2iMAcDaCEQDcoPT0dCUkJNhCykMPPaRdu3Zp586dkq4Eg/bt22vdunW6cOGC7XnZ2dlavXq12rdvL09PT/3888965plnVL58eX3++ef65JNPlJWVpUcffVSnTp2yO+f777+vN954Q++9954k6b333tMHH3ygoUOHKiEhQTNmzFBaWppiYmJsz9mzZ4+ef/553X777Zo/f75GjRqlyZMn55nFeeWVV/TRRx+pT58+io+P1/DhwzV//nyNGTPmhnvk7e2txo0ba8OGDZKuBIqnn35aR44c0ccff6xVq1bp+eef1/Tp0zV37tx/fb1atWopNDRUixYtstu+a9cu7d27V926dctXXb/++qtiY2MVExOjhx9+WO7u7mrSpIld+Dl58qRSUlIUHh6uRo0a2cYgSSkpKTpx4kSey+jmzJkjPz8/ffnll5o8ebI2bdqUr3uj3nnnHYWHh2vhwoV6+eWXtXLlSk2YMEGenp568MEHtWrVKmVmZtqOz30Pde3aVe7u7td97Q4dOmjNmjXKyMiwbfvhhx905swZtWnTJs/x/fv3V2JiosaOHatvvvlGw4cP19KlSzVs2DC74/bs2aOFCxdq0qRJmj9/vooXL65hw4bp/PnzateuneLi4iRd+eXB3+9z2rZtm9avX6/p06frs88+U3Z2tuLi4uyCMQAYgWAEADdoyZIl8vT0VLt27SRJjRs3VpUqVexmjTp27KjMzEz98MMPtm0bN25Uenq6OnXqJEmaOXOmAgICNHHiRNWoUUPBwcGaPHmyMjIy9NVXX9mds127doqIiFC5cuUkST179tTSpUv1wAMPqFKlSqpXr54eeugh7dixwxaq4uPjJUkTJkzQ3XffrcaNG2vixIk6cuSI7XWPHTumhQsXql+/furevbtuv/12tWvXTs8++6wWLVqUr1mPa6lUqZLdvTuzZs3Se++9pzp16iggIEAdOnRQnTp17Hp0PT169NCmTZt08OBB27bly5crICBAkZGR//r8ffv2qX///nr44YfVv39/2/ZmzZrp+PHjSklJkXTlUjkvLy+FhYWpSZMm2rVrl9LT0yXJdmlaVFSU3Wvfcccdeuqpp1S9enXdf//9ioiI0G+//favNUVGRqpnz56qXr26OnfurE6dOik+Pl45OTnq3r27/vrrL61cudJ2fFJSkqxWqx566KF/fe127dopOztby5cvt21btGiRoqKiVLp0abtjf/31V23evFkvvvii7rvvPlWtWlXt2rVT//79tWbNGrv3zNGjR/Xmm2+qTp06CgwMVK9evWS1WnXgwAHddttt8vHxkXRl1urvl0VmZmbq9ddfV61atRQSEqKHHnpIaWlpee7vAgBXIxgBwA36+uuv1bZtW3l7e0u6MkPUtWtXxcfH2y4/CwwMVK1atbRq1Srb81asWKHq1aurfv36kqTffvtNjRs3tvvNf9myZVWzZk3b7FOuoKAgu8fFihXT0qVL1bFjRzVq1EihoaF64403JMn2Q/wff/yh22+/XX5+frbnBQYGqnLlyrbH27dv1+XLl9W0aVO712/SpIlycnLy1OGI7Oxs29gsFovOnDmj119/XS1btlRYWJhCQ0OVnJyc74Ur2rZtKz8/P7tZoxUrVujBBx+UxWK57nNPnjypfv36KSoqSi+++KLdvtzZn9xZox9//FGhoaEqVqyYGjRoIA8PD9usUVJSku6++26VL1/e7jVCQ0PtHvv7+9vN9FxLgwYN7B4HBgbq7NmzOn78uAICAtSsWbM8442IiFDVqlX/9bVLly6tZs2a2S6ns1qtSkxMvOoqfMnJyZKk8PDwq47r7++DatWqyd/f3+48knTmzJnr1lOnTh15eXnZHue+Rn76BADO5GF0AQBwK9q6dat+//13/f7773YzRLkSEhJsM0kdO3bU+++/r6ysLFksFiUkJKhPnz62YzMyMrR48WK73+hL0oULF+x+gJQkX19fu8dxcXFav3694uLiFBERoeLFi2v16tV2l29ZrVZbePu7v88W5F5m9cQTT9jdM5O7mtnN/Db/wIEDqlKliiTpyJEjevTRR1WtWjW9/PLLqlq1qjw8PGyXXeVHsWLF1KVLFy1evFiDBg3Stm3bdPToUdsljdeTe69MQECAcnJy7IJUhQoVVKtWLf344496/PHHtXHjRj388MOSpOLFiyskJEQbN25U69attWnTJvXq1SvP69922212jy0Wy1VXhPunv4fW3PNJ0vnz5yVdmSUbMGCA/vjjD1WsWFEJCQkaO3bsv75urujoaNtKgRs3bpSnp+dV7y/KfR/8832WO/vz9/BSokQJu2Nye/lv480dm6PPAwBnIxgBwA1YsGCBqlevrnfeeSfPvjfeeENff/21LRh16NBBb7/9ttavXy83NzedOXNG0dHRtuNLliypqKgoDRo0KM9r/TMY/V1GRobWrVunp556yi5o/fNeDS8vrzxLTUv2gSn3B/NJkyapVq1aeY79+8yAI06dOmUXIhISEnTu3Dm9/fbbuvPOO23HnTlzJk84uJ7u3btr9uzZ2rJli1avXq1mzZqpYsWK//q8Vq1aqXv37urTp4/ee+89DRgwwG5/VFSUvvrqKx04cECHDx9WkyZNbPsaN26sZcuWafv27Tp37lyBLtP9z9mS3IUOcv9+WrRooYoVKyo+Pl61atWSu7u77r///ny/fsuWLeXr66sVK1boxx9/VOvWrfMEFOnKe1G6sgDD3/efPXvWbj8AFEVcSgcADjp37pxWrFihDh06qHbt2nm+OnXqpKSkJNv9GJUrV1ZYWJgSEhK0cuVKhYWF2V0CFRISotTUVFWrVs3uKzs723Yv0dVcvHhROTk5dqHl0qVLWrp0qd1x1apV0/79+3X69Gnbtu3btystLc32OCgoSO7u7jp8+LBdDeXKlZObm1ueGYT8uHz5sl555RW5u7vbPiA1dxW+v9f8yy+/aP/+/Q7NGNx5552KiIjQ0qVLtWLFinwvutChQweFh4dr0KBBmjZtmrZs2WK3v3nz5srIyND8+fPl6+trd+likyZNtH//fq1du1be3t4KCwvLd73/5qeffrJ7vHPnTpUuXVply5aVJLm7u+uhhx7S8uXLFR8fr+jo6OuG5n8qVqyY2rRpoxUrVmjr1q1XvYxOkm3p8X8uTb5lyxa5ubmpTp06jgxLEjNBAG4dBCMAcNDy5cuVmZlpmxH6p9atW8vd3d1uieSOHTtq/fr1+u6772yLLuTq16+fUlJSNHbsWO3evVv79+/XzJkz1bFjR9vyx1dTunRpVa9eXQsXLlRKSop27dqlZ5991na/yqZNm5SRkaG2bdvq4sWLevXVV/W///1PP//8s8aMGaOAgADba5UtW1YPPfSQpk2bpsWLF+vgwYPatm2bYmJi9Oijj9ou6bqWCxcu6Pjx4zp+/LgOHz6s7777Tn369NG6des0adIkVapUSdKVEChdWV3v0KFDSkhI0Kuvvqp7771XBw8e1L59+/K9OlmPHj1slzHec889+XpOrqeffloNGjRQXFycXWBs0KCBSpQooa+++kqNGjWyu++rXr16tn2NGzeWp6enQ+e8nqSkJM2fP19//PGHvv76a8XHx6tLly52x3Tr1k379+/XmjVr8h0E/65Tp07au3evypQpc81FKurVq6fGjRvrzTff1LfffquDBw9qyZIleu+999S5c+c891RdT+4M4HfffWdb0AIACjMupQMAB3399de6++67ddddd111v5+fn5o2bapFixZpwIABslgseuCBB/T666/b/vx34eHh+vDDDzV16lQ9/PDDunz5sgIDA/Wf//xHrVq1um4tEydO1NixY9WtWzdVqFBBTz/9tDp16qQ9e/Zo3Lhx8vDw0EMPPaRx48ZpxowZ6tq1q2rWrKkXX3xR48ePt5t1ePnll1W+fHlNnTpVR48elbe3t6KiovTZZ59d9bKrv1u7dq3Wrl0r6crsRrly5RQZGamxY8fa9SksLEyxsbH69NNP9eWXX9pW4EtPT9fAgQPVo0cPJSQkXPdcue677z65ubmpa9eu8vBw7L8zNzc3TZo0SdHR0Ro1apRtOWkvLy81atRI3377rd1ldJLk6emphg0b6rvvvivQy+gk2ZbEfuONN+Tm5qZOnTrl+UymChUqKCwsTBcvXrzq5Y7/pmHDhgoICFDLli2vu8T39OnTNWHCBI0cOVJWq1UVKlTQo48+qoEDBzp0vhYtWigsLExvvvmmatWqddXPngKAwsSSwxw3ABR5p06dkq+vr22WIzs7W02bNlW7du1u6nOKjLR69Wq98MILWrt2rSpUqGB0OU537NgxtW7dWhMmTMgTrgEAN48ZIwAo4lJTUxUdHa3o6Gj169dPkvTJ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USNt2LBB8fHxOnnypMaOHWt0aS63a9cuLVmyxOgyDLNy5UolJyfbvkaPHm10SS41d+5cLV26VHPmzNH69etVo0YNffzxx0aX5RINGza0+7tPTk7WwIED1bZtW6NLc5ns7Gw9/fTTCgkJUVJSkuLj43Xq1ClT/VtotVrVr18/1a9fX+vXr9esWbM0d+5cffPNN0aX5jTX+zlo165dGj58uOLi4rRx40b17dtXAwcO1NGjRw2o1DmuN/5z586pZ8+eslqtRXql5ev14LffflNcXJxiYmK0adMmvfTSS3r11Vdtt84UBgSjAlSsWDEtWLDAtMHozJkzCgoKUmxsrLy9vVWxYkV16dKlUL3hne38+fMaMmSInnnmGXl5ecnf31+tW7fWnj17jC7NpS5fvqwxY8aob9++RpcCg8yaNUtDhgzRnXfeKR8fH40aNUqjRo0yuixDHD58WLNnz9awYcOMLsVljh8/ruPHj6tTp07y8vJS6dKl1bp1a+3atcvo0lxm69atyszM1ODBg1W8eHHVrFlTTz75pBYsWGB0aU5zvZ+D5s+frxYtWqhFixYqVqyYoqOjVatWLS1dutSASp3jeuM/d+6cHnzwQY0fP96Aylznej2wWq165plndN9998nDw0MtWrRQrVq1CtXPiQSjAtS7d2/5+t66H2R4s0qWLKnx48erbNmytm1HjhxR+fLlDazKtfz8/NStWzd5eFy5fW/v3r1atGiRqX5TLElffvmlihUrpo4dOxpdimEmT56se+65R+Hh4Ro9erQyMzONLslljh07pkOHDun06dNq166dIiIiFBMTY7rLqHJNmTJFDz74oCpXrmx0KS5ToUIF1a5dW/PmzVNmZqZOnjyp1atXm27RpNzbA3L5+fkV6XB4vZ+DduzYoTp16thtq1OnjpKTk11Rmktcb/xly5ZVjx49XFyR612vB82bN9dzzz1ne5ydna3jx4+rQoUKrirvXxGM4DTJycn67LPP9OyzzxpdisulpaUpKChI7dq1U3BwsGJiYowuyWVOnDihqVOnasyYMUaXYpiQkBBFRkZq9erVmjdvnrZu3apXXnnF6LJcJvfSmJUrV2r27NlasmSJjh49asoZo0OHDmn16tV6/PHHjS7Fpdzc3DR16lStXbtWYWFhioyMVHZ2tmJjY40uzWVCQ0NVvHhxTZkyRefPn9cff/yhzz//XKdPnza6NENYrVb5+fnZbfPz81N6erpBFcFokyZNUokSJdSuXTujS7EhGMEptmzZoieffFKxsbGKjIw0uhyXCwgIUHJyslauXKn9+/eb6hKa8ePHq2vXrqpRo4bRpRhm3rx56tatm7y8vHTXXXcpLi5O8fHxysrKMro0l8i9fr5fv36qUKGCKlasqEGDBikxMVEXLlwwuDrXmjt3ru6//36VK1fO6FJcKisrS/3797d99Mb3338vX19fxcXFGV2ay/j5+Wn69OnasGGDmjZtqqFDh6pTp05yd3c3ujTDFOV7a5B/OTk5mjhxouLj4zVjxgwVK1bM6JJsCEYocImJiXr66af10ksvqXfv3kaXYxiLxaLq1atryJAhthuPi7oNGzbo119/tZsqh1SlShVdunRJJ0+eNLoUl8i9nLZkyZK2bQEBAcrJyTFND3KtWrVKLVu2NLoMl9uwYYMOHTqkF154Qb6+vqpQoYJiYmK0Zs0aWa1Wo8tzmfDwcM2fP1+//PKL5s2bp1KlShWqy4ZcqXTp0nn+7q1Wq/z9/Y0pCIa4fPmyRowYocTERH3xxRe68847jS7JDsEIBeqXX37R8OHDNWXKFHXu3Nnoclxuw4YNatOmjS5fvmzb5uZ25dvM09PTqLJcZunSpTp58qTuvfdeRUREqGvXrpKkiIgILV++3ODqXGPnzp1688037balpqbKy8vLNPfbVaxYUT4+Pnb3UqSlpcnT09M0PZCurMKVlpampk2bGl2Ky126dEmXL1+2myEwy4xprgsXLmjRokXKyMiwbfvxxx8VGhpqYFXGCQoK0vbt2+22JScnq379+gZVBCO88cYb2rNnj7744gtVrVrV6HLyIBihwGRnZ2vUqFGKi4tTVFSU0eUYIigoSBkZGZo4caLOnz+vU6dOaerUqQoPDzfFwhwjRozQqlWrtGTJEi1ZskQzZ86UJC1ZssQ0vzUvU6aM5s2bp5kzZyorK0v79u3TlClT9PDDD5vmEhoPDw899NBDeu+993TgwAGdPHlS06dPV8eOHW0Lk5jBzp07VapUKfn4+BhdisuFhoaqRIkSmjp1qs6fP6/09HTNmDFDDRs2VKlSpYwuzyU8PT01bdo0zZgxQ9nZ2Vq/fr2WLl2qPn36GF2aIbp3766kpCR9++23unDhghYsWKD9+/crOjra6NLgIlu2bNHSpUs1c+bMQvvvgCWHCz4LTHBwsKQrAUGS7QeAorTiyvVs3rxZvXr1kpeXV559K1euVEBAgAFVuV5KSorGjRun3377TSVKlFDjxo01YsQIU14+cejQIbVq1UopKSlGl+JSmzZt0uTJk5WSkiIvLy916dJFQ4YMKVTXUTtbVlaWxo8fr+XLl+vixYtq06aNRo8eLW9vb6NLc5n3339fy5YtU3x8vNGlGGL79u166623tHv3bnl5ealRo0am+7cwOTlZY8aMUWpqqipWrKi4uDi1bt3a6LKc5t9+Dlq9erUmT56stLQ01ahRQyNHjlTDhg2NKdYJrjf+xYsX2z7PLisrS56enrJYLOrUqZPGjRtnTMFOcL0evPTSS1q0aFGeX5A1bNhQs2bNcm2h10AwAgAAAGB6XEoHAAAAwPQIRgAAAABMj2AEAAAAwPQIRgAAAABMj2AEAAAAwPQIRgAAAABMj2AEAAAAwPQIRgAAAABMj2AEAICkQ4cOKTAwUKmpqUaXAgAwAMEIAFDotGzZUiEhIcrMzMyz7+OPP1ZgYKAWLlx40+dZvXq1Dhw4cNOvAwC49RGMAACFUokSJZSQkJBn+7Jly+Tv718g53j33XcJRgAASQQjAEAh1aJFCy1dutRu24EDB5Senq4aNWrYtn355Zdq27at6tevrwceeEArVqyw7Xvsscf03nvvaejQoQoLC1OzZs20ZMkSSVJ0dLT27NmjAQMG6MUXX7Q9Z9++fXrwwQcVHByshx9+WEePHnXySAEAhQHBCABQKLVs2VJbtmzRiRMnbNuWLVumNm3a2B4nJiZq4sSJeu2117R582bFxMRo6NChSklJsR0zd+5cRUdH66efflL37t316quv6uLFi7bQ9d///lfjx4+3HT9//nzNmDFD3333nTIyMvThhx+6YLQAAKMRjAAAhVLJkiUVFRVlNwO0fPlyRUdH2x4vWLBAHTp0UHh4uDw9PdWuXTvVrl1bq1atsh0TGhqqZs2aydPTU23btlVGRob+/PPPa563Z8+eKl++vPz9/dWkSRPt27fPOQMEABQqBCMAQKHVuXNn28zOzp075ebmptq1a9v2Hzp0SHfddZfdc6pVq6a0tDTb4ypVqtj+fNttt0mS/vrrr2ue85/HZ2Vl3dwgAAC3BIIRAKDQat68uQ4ePKj9+/dr2bJl6tixo93+a4UWi8Vi+7ObG//VAQD+Hf9bAAAKLS8vL7Vt21arVq3SqlWr1KFDB7v9t99+u/bu3Wu3be/evapataorywQAFAEEIwBAoda5c2fNmzdPFSpUsLvMTZI6deqkZcuWaevWrbp48aIWLlyoPXv2qH379vl67WLFiunAgQPKyMhwRukAgFuIh9EFAABwPSEhIfL09MxzGZ0ktW/fXmlpaRo2bJhOnDihO++8U7NmzVL16tXz9do9evTQhAkTlJSUpJEjRxZw5QCAW4klJycnx+giAAAAAMBIXEoHAAAAwPQIRgAAAABMj2AEAAAAwPQIRgAAAABMj2AEAAAAwPQIRgAAAABMj2AEAAAAwPQIRgAAAABMj2AEAAAAwPQIRgAAAABMj2AEAAAAwPT+H1tbncDnPsupAAAAAElFTkSuQmCC\n"
          },
          "metadata": {}
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\n",
            "--- End of EDA ---\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "id": "729be8bf",
      "metadata": {
        "id": "729be8bf"
      },
      "source": [
        "## 4. Feature Engineering\n",
        "\n",
        "Create features based on the date and potentially other aspects of the data. For this baseline, we will focus on date-based features. More advanced features (lags, rolling windows, user-specific stats) can be added later for improvement."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 63,
      "id": "49f9eba0",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "collapsed": true,
        "id": "49f9eba0",
        "outputId": "1eb16809-3ac9-4692-e4c0-1331ade1eac6"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "--- Step 0: Converting user_id to Category ---\n",
            "Original user_id dtype: category\n",
            "Converted user_id dtype: category\n",
            "\n",
            "--- Step 1: Creating Lag Features ---\n",
            "Sorting data by user_id and date...\n",
            "Calculating lags for column: 'daily_kwh' using periods: [1, 2, 3, 7, 14, 28]\n",
            "[0.1s] Created lag features: ['daily_kwh_lag_1', 'daily_kwh_lag_2', 'daily_kwh_lag_3', 'daily_kwh_lag_7', 'daily_kwh_lag_14', 'daily_kwh_lag_28']\n",
            "\n",
            "--- Step 3: Creating Date Features ---\n",
            "[0.1s] Date features applied.\n",
            "\n",
            "--- Step 4: Defining Final Feature List ---\n",
            "Added 'user_id' to features list.\n",
            "Adding 6 lag features.\n",
            "\n",
            "Final list of features defined (19): ['year', 'month', 'day', 'dayofweek', 'dayofyear', 'weekofyear', 'quarter', 'is_weekend', 'temp_mean', 'dew_point_mean', 'wind_speed_mean', 'precip_sum', 'user_id', 'daily_kwh_lag_1', 'daily_kwh_lag_2', 'daily_kwh_lag_3', 'daily_kwh_lag_7', 'daily_kwh_lag_14', 'daily_kwh_lag_28']\n",
            "\n",
            "--- Step 5: Checking Data Types & Handling NaNs ---\n",
            "Checking for non-numeric feature columns (excluding category)...\n",
            "\n",
            "Handling remaining NaNs in features (filling with 0)...\n",
            "NaN counts BEFORE fill (numeric features only):\n",
            "daily_kwh_lag_1      1\n",
            "daily_kwh_lag_2      2\n",
            "daily_kwh_lag_3      3\n",
            "daily_kwh_lag_7      7\n",
            "daily_kwh_lag_14    14\n",
            "daily_kwh_lag_28    28\n",
            "dtype: int64\n",
            "\n",
            "[ OK ] NaNs handled. Total remaining (numeric): 0\n",
            "\n",
            "[0.2s] Cell 8 processing finished.\n",
            "\n",
            "--- Training Data with New Features Head (Sample) ---\n",
            "       user_id       date  daily_kwh  year  month user_id  daily_kwh_lag_1  \\\n",
            "118392     0.0 2023-06-03   0.000922  2023      6     0.0         0.000000   \n",
            "116407     0.0 2023-06-03   0.001066  2023      6     0.0         0.000922   \n",
            "116010     0.0 2023-06-03   0.001183  2023      6     0.0         0.001066   \n",
            "115216     0.0 2023-06-03   0.001009  2023      6     0.0         0.001183   \n",
            "116804     0.0 2023-06-03   0.001094  2023      6     0.0         0.001009   \n",
            "\n",
            "        daily_kwh_lag_2  \n",
            "118392         0.000000  \n",
            "116407         0.000000  \n",
            "116010         0.000922  \n",
            "115216         0.001066  \n",
            "116804         0.001183  \n"
          ]
        }
      ],
      "source": [
        "# Cell 8: Feature Engineering (Date + Lag + Rolling + UserID)\n",
        "\n",
        "import time\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "\n",
        "feature_eng_start_time = time.time()\n",
        "\n",
        "# --- Check for input DataFrame ---\n",
        "if 'df_train_full' not in locals():\n",
        "    raise NameError(\"df_train_full not found. Ensure Cell 6 ran successfully.\")\n",
        "\n",
        "# --- 0. Convert user_id to Category dtype --- <<<< NEW STEP >>>>\n",
        "print(\"--- Step 0: Converting user_id to Category ---\")\n",
        "if 'user_id' in df_train_full.columns:\n",
        "    print(f\"Original user_id dtype: {df_train_full['user_id'].dtype}\")\n",
        "    df_train_full['user_id'] = df_train_full['user_id'].astype('category')\n",
        "    print(f\"Converted user_id dtype: {df_train_full['user_id'].dtype}\")\n",
        "else:\n",
        "    raise KeyError(\"Column 'user_id' not found in df_train_full.\")\n",
        "\n",
        "\n",
        "# --- 1. Create Lag Features ---\n",
        "print(\"\\n--- Step 1: Creating Lag Features ---\")\n",
        "print(\"Sorting data by user_id and date...\")\n",
        "df_train_full = df_train_full.sort_values(by=['user_id', 'date'])\n",
        "\n",
        "lags_to_create = [1, 2, 3, 7, 14, 28]\n",
        "lag_col_name_base = 'daily_kwh_lag_'\n",
        "lag_cols_created = []\n",
        "\n",
        "target_col_for_lags = 'daily_kwh'\n",
        "print(f\"Calculating lags for column: '{target_col_for_lags}' using periods: {lags_to_create}\")\n",
        "for lag in lags_to_create:\n",
        "    col_name = f\"{lag_col_name_base}{lag}\"\n",
        "    df_train_full[col_name] = df_train_full.groupby('user_id', observed=True)[target_col_for_lags].shift(lag) # added observed=True\n",
        "    lag_cols_created.append(col_name)\n",
        "print(f\"[{time.time() - feature_eng_start_time:.1f}s] Created lag features: {lag_cols_created}\")\n",
        "\n",
        "\n",
        "# --- 2. Create Rolling Window Features ---\n",
        "#print(\"\\n--- Step 2: Creating Rolling Window Features ---\")\n",
        "#windows = [7, 14, 28]\n",
        "#stats = ['mean', 'std', 'min', 'max']\n",
        "#rolling_cols_created = []\n",
        "\n",
        "#target_col_for_rolling = 'daily_kwh'\n",
        "#print(f\"Calculating rolling stats for column: '{target_col_for_rolling}' using windows: {windows}\")\n",
        "# Use observed=True for groupby with category dtype\n",
        "#grouped = df_train_full.groupby('user_id', observed=True)[target_col_for_rolling]\n",
        "\n",
        "#for window in windows:\n",
        "#    print(f\"  Processing window size: {window}\")\n",
        "#    shifted_grouped = grouped.shift(1)\n",
        "#    rolling_object = shifted_grouped.rolling(window=window, min_periods=1)\n",
        "#    for stat in stats:\n",
        "#         col_name = f'daily_kwh_roll_{window}_{stat}'\n",
        "#         print(f\"    Calculating: {stat} -> {col_name}\")\n",
        "#        df_train_full[col_name] = rolling_object.agg(stat)\n",
        "#        rolling_cols_created.append(col_name)\n",
        "#print(f\"[{time.time() - feature_eng_start_time:.1f}s] Created rolling window features: {rolling_cols_created}\")\n",
        "\n",
        "\n",
        "# --- 3. Create Date Features ---\n",
        "print(\"\\n--- Step 3: Creating Date Features ---\")\n",
        "def create_date_features(df, date_col='date'):\n",
        "    \"\"\"Creates time series features from a date column.\"\"\"\n",
        "    df = df.copy()\n",
        "    df[date_col] = pd.to_datetime(df[date_col])\n",
        "    df['year'] = df[date_col].dt.year\n",
        "    df['month'] = df[date_col].dt.month\n",
        "    df['day'] = df[date_col].dt.day\n",
        "    df['dayofweek'] = df[date_col].dt.dayofweek\n",
        "    df['dayofyear'] = df[date_col].dt.dayofyear\n",
        "    df['weekofyear'] = df[date_col].dt.isocalendar().week.astype(int)\n",
        "    df['quarter'] = df[date_col].dt.quarter\n",
        "    df['is_weekend'] = (df['dayofweek'] >= 5).astype(int)\n",
        "    return df\n",
        "\n",
        "df_train_full = create_date_features(df_train_full, 'date')\n",
        "print(f\"[{time.time() - feature_eng_start_time:.1f}s] Date features applied.\")\n",
        "\n",
        "\n",
        "# --- 4. Define Final Feature List ---\n",
        "print(\"\\n--- Step 4: Defining Final Feature List ---\")\n",
        "base_features = [\n",
        "    'year', 'month', 'day', 'dayofweek', 'dayofyear', 'weekofyear', 'quarter', 'is_weekend',\n",
        "    'temp_mean', 'dew_point_mean', 'wind_speed_mean', 'precip_sum'\n",
        "]\n",
        "features = list(base_features)\n",
        "\n",
        "# --- Add user_id feature --- <<<< NEW >>>>\n",
        "features.append('user_id')\n",
        "print(\"Added 'user_id' to features list.\")\n",
        "\n",
        "# Add lag features\n",
        "if 'lag_cols_created' in locals() and isinstance(lag_cols_created, list):\n",
        "    print(f\"Adding {len(lag_cols_created)} lag features.\")\n",
        "    features.extend(lag_cols_created)\n",
        "else: print(\"WARNING: Lag features not added.\")\n",
        "\n",
        "# Add rolling window features\n",
        "#if 'rolling_cols_created' in locals() and isinstance(rolling_cols_created, list):\n",
        "#    print(f\"Adding {len(rolling_cols_created)} rolling features.\")\n",
        "#    features.extend(rolling_cols_created)\n",
        "#else: print(\"WARNING: Rolling window features not added.\")\n",
        "\n",
        "target = 'daily_kwh'\n",
        "print(f\"\\nFinal list of features defined ({len(features)}): {features}\")\n",
        "\n",
        "\n",
        "# --- 5. Check Feature Data Types and Handle NaNs ---\n",
        "print(\"\\n--- Step 5: Checking Data Types & Handling NaNs ---\")\n",
        "missing_features = [f for f in features if f not in df_train_full.columns]\n",
        "if missing_features: raise ValueError(f\"Features defined but missing: {missing_features}\")\n",
        "\n",
        "print(\"Checking for non-numeric feature columns (excluding category)...\")\n",
        "for col in features:\n",
        "    # Exclude category type from numeric conversion check\n",
        "    if col != 'user_id' and not pd.api.types.is_numeric_dtype(df_train_full[col]):\n",
        "        print(f\"  Warning: Feature '{col}' not numeric ({df_train_full[col].dtype}). Converting.\")\n",
        "        df_train_full[col] = pd.to_numeric(df_train_full[col], errors='coerce')\n",
        "        if df_train_full[col].isnull().any():\n",
        "             print(f\"    NaNs from conversion in {col}, filling with 0.\")\n",
        "             df_train_full[col].fillna(0, inplace=True)\n",
        "\n",
        "print(f\"\\nHandling remaining NaNs in features (filling with 0)...\")\n",
        "# Exclude user_id from NaN filling as it's categorical\n",
        "numeric_features_for_nan_fill = [f for f in features if f != 'user_id']\n",
        "nan_counts_before_fill = df_train_full[numeric_features_for_nan_fill].isnull().sum()\n",
        "print(\"NaN counts BEFORE fill (numeric features only):\")\n",
        "print(nan_counts_before_fill[nan_counts_before_fill > 0])\n",
        "df_train_full[numeric_features_for_nan_fill] = df_train_full[numeric_features_for_nan_fill].fillna(0)\n",
        "nan_counts_after_fill = df_train_full[numeric_features_for_nan_fill].isnull().sum().sum()\n",
        "if nan_counts_after_fill == 0: print(f\"\\n[ OK ] NaNs handled. Total remaining (numeric): {nan_counts_after_fill}\")\n",
        "else: print(f\"\\n[ WARNING ] NaNs remain after fill (numeric): {nan_counts_after_fill}.\")\n",
        "\n",
        "feature_eng_total_time = time.time() - feature_eng_start_time\n",
        "print(f\"\\n[{feature_eng_total_time:.1f}s] Cell 8 processing finished.\")\n",
        "\n",
        "print(\"\\n--- Training Data with New Features Head (Sample) ---\")\n",
        "cols_to_show = (['user_id', 'date', target] + base_features[:2] + ['user_id'] +\n",
        "                lag_cols_created[:2])\n",
        "print(df_train_full[cols_to_show].head())"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "a487309a",
      "metadata": {
        "id": "a487309a"
      },
      "source": [
        "## 5. Train/Validation Split (Time-Based)\n",
        "\n",
        "For time series forecasting, it's crucial to validate the model on data that comes *after* the training data. We will split the data chronologically, using the most recent period for validation. Shuffling should **not** be used."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 64,
      "id": "fd68efd1",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "fd68efd1",
        "outputId": "2471b6c3-95b2-4ee6-9a6e-8265e2bd11ff"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "--- Setting up Time Series Cross-Validation ---\n",
            "Sorting data by date for TimeSeriesSplit...\n",
            "Full data shape for CV: X=(136409, 19), y=(136409,)\n",
            "Using TimeSeriesSplit with 5 splits.\n",
            "Using LGBM parameters: {'objective': 'regression_l1', 'metric': 'rmse', 'n_estimators': 2000, 'learning_rate': 0.03, 'feature_fraction': 0.8, 'bagging_fraction': 0.8, 'bagging_freq': 1, 'lambda_l1': 1, 'lambda_l2': 1, 'num_leaves': 21, 'verbose': -1, 'n_jobs': -1, 'seed': 42, 'boosting_type': 'gbdt'}\n",
            "\n",
            "--- Starting Cross-Validation Training ---\n",
            "\n",
            "--- Fold 1/5 ---\n",
            "Train size: 22739, Val size: 22734\n",
            "Training model for fold...\n",
            "Fold 1 RMSE: 3.7601 (Best iteration: 1066)\n",
            "Fold 1 completed in 11.7s\n",
            "\n",
            "--- Fold 2/5 ---\n",
            "Train size: 45473, Val size: 22734\n",
            "Training model for fold...\n",
            "Fold 2 RMSE: 0.0000 (Best iteration: 1)\n",
            "------ Diagnostics for Fold 2 (RMSE is ~0) ------\n",
            "  Validation target non-null count: 22734\n",
            "  Validation target unique values count: 1\n",
            "  Unique values: [0.]\n",
            "  Min: 0.0000, Max: 0.0000, Mean: 0.0000, StdDev: 0.0000\n",
            "  Predictions Min: 0.0000, Max: 0.0000, Mean: 0.0000, StdDev: 0.0000\n",
            "------ End Diagnostics ------\n",
            "Fold 2 completed in 0.8s\n",
            "\n",
            "--- Fold 3/5 ---\n",
            "Train size: 68207, Val size: 22734\n",
            "Training model for fold...\n",
            "Fold 3 RMSE: 0.0000 (Best iteration: 1)\n",
            "------ Diagnostics for Fold 3 (RMSE is ~0) ------\n",
            "  Validation target non-null count: 22734\n",
            "  Validation target unique values count: 1\n",
            "  Unique values: [0.]\n",
            "  Min: 0.0000, Max: 0.0000, Mean: 0.0000, StdDev: 0.0000\n",
            "  Predictions Min: 0.0000, Max: 0.0000, Mean: 0.0000, StdDev: 0.0000\n",
            "------ End Diagnostics ------\n",
            "Fold 3 completed in 1.0s\n",
            "\n",
            "--- Fold 4/5 ---\n",
            "Train size: 90941, Val size: 22734\n",
            "Training model for fold...\n",
            "Fold 4 RMSE: 2.6129 (Best iteration: 11)\n",
            "Fold 4 completed in 1.2s\n",
            "\n",
            "--- Fold 5/5 ---\n",
            "Train size: 113675, Val size: 22734\n",
            "Training model for fold...\n",
            "Fold 5 RMSE: 7.6853 (Best iteration: 550)\n",
            "Fold 5 completed in 12.4s\n",
            "\n",
            "--- Cross-Validation Summary ---\n",
            "Individual Fold RMSEs: [3.7601, 0.0, 0.0, 2.6129, 7.6853]\n",
            "Mean CV RMSE (All Folds): 2.8117\n",
            "Std Dev CV RMSE (All Folds): 2.8461\n",
            "\n",
            "--- Realistic CV Summary (Excluding Zero-RMSE Folds) ---\n",
            "Scores Used: [3.7601, 2.6129, 7.6853]\n",
            "Mean Realistic CV RMSE: 4.6861\n",
            "Std Dev Realistic CV RMSE: 2.1719\n",
            "\n",
            "Total CV Time: 27.0s\n"
          ]
        }
      ],
      "source": [
        "# Cell 9: Time Series Cross-Validation (with UserID, Diagnostics, Realistic Score)\n",
        "\n",
        "from sklearn.model_selection import TimeSeriesSplit\n",
        "import lightgbm as lgb\n",
        "from sklearn.metrics import mean_squared_error\n",
        "import math\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt # Import matplotlib for optional plot\n",
        "import time # Import time\n",
        "\n",
        "print(\"--- Setting up Time Series Cross-Validation ---\")\n",
        "\n",
        "# --- Check required inputs ---\n",
        "if 'df_train_full' not in locals(): raise NameError(\"df_train_full not found.\")\n",
        "if 'features' not in locals(): raise NameError(\"features list not defined.\")\n",
        "if 'target' not in locals(): raise NameError(\"target variable name not defined.\")\n",
        "if 'SEED' not in locals(): SEED = 42; print(\"Warning: SEED not found, using 42.\")\n",
        "\n",
        "# --- Prepare full dataset ---\n",
        "print(\"Sorting data by date for TimeSeriesSplit...\")\n",
        "df_train_full = df_train_full.sort_values(by='date')\n",
        "# Ensure user_id is category type before splitting\n",
        "if df_train_full['user_id'].dtype.name != 'category':\n",
        "    print(\"Warning: Converting user_id back to category in CV setup.\")\n",
        "    df_train_full['user_id'] = df_train_full['user_id'].astype('category')\n",
        "\n",
        "X_full = df_train_full[features]\n",
        "y_full = df_train_full[target]\n",
        "print(f\"Full data shape for CV: X={X_full.shape}, y={y_full.shape}\")\n",
        "\n",
        "# --- Configure TimeSeriesSplit ---\n",
        "N_SPLITS = 5\n",
        "tscv = TimeSeriesSplit(n_splits=N_SPLITS)\n",
        "print(f\"Using TimeSeriesSplit with {N_SPLITS} splits.\")\n",
        "\n",
        "# --- Define LightGBM Parameters ---\n",
        "lgb_params = {\n",
        "    'objective': 'regression_l1', 'metric': 'rmse', 'n_estimators': 2000,\n",
        "    'learning_rate': 0.03, 'feature_fraction': 0.8, 'bagging_fraction': 0.8,\n",
        "    'bagging_freq': 1, 'lambda_l1': 1, 'lambda_l2': 1, 'num_leaves': 21,\n",
        "    'verbose': -1, 'n_jobs': -1, 'seed': SEED, 'boosting_type': 'gbdt',\n",
        "}\n",
        "print(f\"Using LGBM parameters: {lgb_params}\")\n",
        "\n",
        "# --- Run Cross-Validation Loop ---\n",
        "oof_predictions = np.zeros(len(df_train_full))\n",
        "fold_scores = []\n",
        "trained_models = []\n",
        "best_iterations = []\n",
        "zero_rmse_folds = [] # Keep track of zero RMSE folds\n",
        "\n",
        "cv_start_time = time.time()\n",
        "print(\"\\n--- Starting Cross-Validation Training ---\")\n",
        "\n",
        "for fold, (train_index, val_index) in enumerate(tscv.split(X_full)):\n",
        "    fold_start_time = time.time()\n",
        "    print(f\"\\n--- Fold {fold+1}/{N_SPLITS} ---\")\n",
        "\n",
        "    X_train, X_val = X_full.iloc[train_index], X_full.iloc[val_index]\n",
        "    y_train, y_val = y_full.iloc[train_index], y_full.iloc[val_index]\n",
        "    print(f\"Train size: {len(train_index)}, Val size: {len(val_index)}\")\n",
        "\n",
        "    model_fold = lgb.LGBMRegressor(**lgb_params)\n",
        "\n",
        "    print(\"Training model for fold...\")\n",
        "    model_fold.fit(X_train, y_train,\n",
        "                   eval_set=[(X_val, y_val)],\n",
        "                   eval_metric='rmse',\n",
        "                   callbacks=[lgb.early_stopping(stopping_rounds=100, verbose=False)],\n",
        "                   categorical_feature=['user_id'] # <<<--- SPECIFY CATEGORICAL FEATURE ---<<<\n",
        "                  )\n",
        "\n",
        "    best_iter = model_fold.best_iteration_\n",
        "    best_iterations.append(best_iter if best_iter else lgb_params['n_estimators'])\n",
        "\n",
        "    val_preds_fold = model_fold.predict(X_val)\n",
        "    val_preds_fold = np.maximum(0, val_preds_fold)\n",
        "\n",
        "    rmse_fold = math.sqrt(mean_squared_error(y_val, val_preds_fold))\n",
        "    fold_scores.append(rmse_fold)\n",
        "    print(f\"Fold {fold+1} RMSE: {rmse_fold:.4f} (Best iteration: {best_iter})\")\n",
        "\n",
        "    # --- Diagnostics for potentially zero RMSE folds ---\n",
        "    # Check if RMSE is effectively zero\n",
        "    if np.isclose(rmse_fold, 0.0):\n",
        "        zero_rmse_folds.append(fold) # Store index of zero fold\n",
        "        print(f\"------ Diagnostics for Fold {fold+1} (RMSE is ~0) ------\")\n",
        "        print(f\"  Validation target non-null count: {y_val.count()}\")\n",
        "        if y_val.count() > 0:\n",
        "            print(f\"  Validation target unique values count: {y_val.nunique()}\")\n",
        "            if y_val.nunique() < 10: print(f\"  Unique values: {np.unique(y_val.dropna())}\")\n",
        "            print(f\"  Min: {y_val.min():.4f}, Max: {y_val.max():.4f}, Mean: {y_val.mean():.4f}, StdDev: {y_val.std():.4f}\")\n",
        "            print(f\"  Predictions Min: {val_preds_fold.min():.4f}, Max: {val_preds_fold.max():.4f}, Mean: {val_preds_fold.mean():.4f}, StdDev: {val_preds_fold.std():.4f}\")\n",
        "        else: print(\"  Validation target slice has no non-null values!\")\n",
        "        print(f\"------ End Diagnostics ------\")\n",
        "\n",
        "    oof_predictions[val_index] = val_preds_fold\n",
        "    # trained_models.append(model_fold) # Optional\n",
        "    fold_time = time.time() - fold_start_time\n",
        "    print(f\"Fold {fold+1} completed in {fold_time:.1f}s\")\n",
        "\n",
        "# --- Calculate and Print Overall & Realistic CV Scores ---\n",
        "mean_cv_rmse = np.mean(fold_scores)\n",
        "std_cv_rmse = np.std(fold_scores)\n",
        "cv_total_time = time.time() - cv_start_time\n",
        "\n",
        "print(\"\\n--- Cross-Validation Summary ---\")\n",
        "print(f\"Individual Fold RMSEs: {[round(s, 4) for s in fold_scores]}\")\n",
        "print(f\"Mean CV RMSE (All Folds): {mean_cv_rmse:.4f}\")\n",
        "print(f\"Std Dev CV RMSE (All Folds): {std_cv_rmse:.4f}\")\n",
        "\n",
        "# Calculate realistic score excluding zero RMSE folds\n",
        "realistic_scores = [score for i, score in enumerate(fold_scores) if i not in zero_rmse_folds]\n",
        "if realistic_scores: # Ensure list is not empty\n",
        "    mean_realistic_cv_rmse = np.mean(realistic_scores)\n",
        "    std_realistic_cv_rmse = np.std(realistic_scores)\n",
        "    print(\"\\n--- Realistic CV Summary (Excluding Zero-RMSE Folds) ---\")\n",
        "    print(f\"Scores Used: {[round(s, 4) for s in realistic_scores]}\")\n",
        "    print(f\"Mean Realistic CV RMSE: {mean_realistic_cv_rmse:.4f}\") # <-- REALISTIC BENCHMARK\n",
        "    print(f\"Std Dev Realistic CV RMSE: {std_realistic_cv_rmse:.4f}\")\n",
        "else:\n",
        "    print(\"\\nWarning: All folds had zero RMSE or calculation failed.\")\n",
        "    mean_realistic_cv_rmse = 0 # Set a default if all folds were zero\n",
        "\n",
        "print(f\"\\nTotal CV Time: {cv_total_time:.1f}s\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0c0e2e18",
      "metadata": {
        "id": "0c0e2e18"
      },
      "source": [
        "## 6. Model Training (LightGBM Baseline)\n",
        "\n",
        "We will use LightGBM, a gradient boosting framework known for its speed and efficiency, to train a baseline model. We'll use early stopping based on the validation set performance (RMSE) to prevent overfitting and find a reasonable number of boosting rounds."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 65,
      "id": "ec1e217c",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ec1e217c",
        "outputId": "b90f6c20-8b08-4c15-9dab-f026f1629141"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\n",
            "--- Training Final Model on Full Data ---\n",
            "Determined optimal rounds from CV median: 11\n",
            "Using parameters for final model: {'objective': 'regression_l1', 'metric': 'rmse', 'n_estimators': 11, 'learning_rate': 0.03, 'feature_fraction': 0.8, 'bagging_fraction': 0.8, 'bagging_freq': 1, 'lambda_l1': 1, 'lambda_l2': 1, 'num_leaves': 21, 'verbose': -1, 'n_jobs': -1, 'seed': 42, 'boosting_type': 'gbdt'}\n",
            "Training final model on 136409 samples...\n",
            "\n",
            "Final model training complete in 0.5s\n"
          ]
        }
      ],
      "source": [
        "# Cell 10: Final Model Training (with UserID)\n",
        "\n",
        "import lightgbm as lgb\n",
        "import numpy as np\n",
        "import time\n",
        "\n",
        "print(\"\\n--- Training Final Model on Full Data ---\")\n",
        "final_model_start_time = time.time()\n",
        "\n",
        "# --- Check for required inputs ---\n",
        "if 'X_full' not in locals(): raise NameError(\"X_full not found.\")\n",
        "if 'y_full' not in locals(): raise NameError(\"y_full not found.\")\n",
        "if 'lgb_params' not in locals(): raise NameError(\"lgb_params not defined.\")\n",
        "if 'best_iterations' not in locals(): raise NameError(\"best_iterations list not found.\")\n",
        "# Ensure user_id is category in X_full\n",
        "if X_full['user_id'].dtype.name != 'category':\n",
        "     print(\"Warning: Converting user_id to category for final model training.\")\n",
        "     X_full['user_id'] = X_full['user_id'].astype('category')\n",
        "\n",
        "\n",
        "# --- Determine Optimal Number of Rounds ---\n",
        "if best_iterations: # Check if list is not empty\n",
        "    optimal_rounds = int(np.median(best_iterations))\n",
        "    # Optional: Add a small safety margin if median seems low due to zero folds\n",
        "    # optimal_rounds = max(50, optimal_rounds) # Ensure at least 50 rounds\n",
        "    print(f\"Determined optimal rounds from CV median: {optimal_rounds}\")\n",
        "else:\n",
        "    print(\"Warning: best_iterations list is empty. Using default n_estimators.\")\n",
        "    optimal_rounds = lgb_params.get('n_estimators', 1000) # Fallback\n",
        "\n",
        "# --- Initialize Final Model ---\n",
        "final_model_params = lgb_params.copy()\n",
        "final_model_params['n_estimators'] = optimal_rounds\n",
        "\n",
        "print(f\"Using parameters for final model: {final_model_params}\")\n",
        "final_model = lgb.LGBMRegressor(**final_model_params)\n",
        "\n",
        "# --- Train on ALL data, specifying categorical feature ---\n",
        "print(f\"Training final model on {X_full.shape[0]} samples...\")\n",
        "final_model.fit(X_full, y_full,\n",
        "                categorical_feature=['user_id'] # <<<--- SPECIFY CATEGORICAL ---<<<\n",
        "               )\n",
        "\n",
        "final_model_time = time.time() - final_model_start_time\n",
        "print(f\"\\nFinal model training complete in {final_model_time:.1f}s\")\n",
        "\n",
        "# Optional: Save the final model\n",
        "# import joblib\n",
        "# joblib.dump(final_model, 'final_lgb_model_v4_userid.pkl')\n",
        "# print(\"Final model saved.\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "3a98dead",
      "metadata": {
        "id": "3a98dead"
      },
      "source": [
        "## 8. Prepare Test Data and Generate Predictions\n",
        "\n",
        "Now we prepare the actual test dataset based on the `SampleSubmission.csv` file. This involves:\n",
        "1.  Extracting the required future `date` and `user_id` from the `ID` column in the sample submission.\n",
        "2.  Merging the relevant aggregated daily `climate` data for those future dates.\n",
        "3.  Creating the same date-based `features` that the model was trained on.\n",
        "4.  Handling any potential missing climate data for future dates (e.g., by forward filling the last known values).\n",
        "5.  Using the trained `model` to predict `daily_kwh` for the test set."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 66,
      "id": "15ab428b",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "15ab428b",
        "outputId": "d0324010-0920-4e15-af44-a9ce5f5b7ca4"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "--- Preparing Test Data (with UserID Conversion) ---\n",
            "[0.2s] Base test structure created.\n",
            "[0.2s] Merging climate data...\n",
            "[0.2s] Climate data merged.\n",
            "[0.2s] Combining history...\n",
            "Need history back to 2024-07-29\n",
            "Combined data shape: (6014, 7)\n",
            "[0.3s] Calculating lag features...\n",
            "Converting combined_df user_id to category for groupby...\n",
            "Lag calculation finished.\n",
            "\n",
            "[0.3s] Creating date features...\n",
            "Date features created.\n",
            "\n",
            "[0.3s] Filtering back to required test dates...\n",
            "Filtered back to test set shape: (6014, 22)\n",
            "\n",
            "[0.3s] Final checks and feature alignment...\n",
            "Converting user_id in test_df_final to category dtype...\n",
            "Handling NaNs in final test features (filling with 0)...\n",
            "[ OK ] Final test features (X_test) prepared. Shape: {X_test.shape}\n",
            "\n",
            "[0.3s] Predicting using final_model...\n",
            "Reordering X_test columns to match model training order.\n",
            "Prediction on test set complete.\n",
            "\n",
            "[0.3s] Cell 16 processing finished.\n"
          ]
        }
      ],
      "source": [
        "# Cell 16: Prepare Test Data (Revised with UserID Conversion)\n",
        "\n",
        "import time\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "\n",
        "print(\"--- Preparing Test Data (with UserID Conversion) ---\")\n",
        "test_prep_start_time = time.time()\n",
        "\n",
        "# --- Check for required inputs ---\n",
        "# (Keep checks for sample_sub, daily_climate, df_train_full, etc.)\n",
        "if 'sample_sub' not in locals(): raise NameError(\"sample_sub not found.\")\n",
        "if 'daily_climate' not in locals(): raise NameError(\"daily_climate not found.\")\n",
        "if 'df_train_full' not in locals(): raise NameError(\"df_train_full not found.\")\n",
        "if 'create_date_features' not in locals(): raise NameError(\"create_date_features not defined.\")\n",
        "if 'features' not in locals(): raise NameError(\"features list not defined.\")\n",
        "if 'final_model' not in locals(): raise NameError(\"Trained 'final_model' not found.\")\n",
        "if 'lag_cols_created' not in locals(): lag_cols_created = []; print(\"Warning: lag_cols_created not defined.\")\n",
        "if 'rolling_cols_created' not in locals(): rolling_cols_created = []; print(\"Warning: rolling_cols_created not defined.\")\n",
        "\n",
        "\n",
        "# --- 1. Create Base Test Set Structure ---\n",
        "test_df_base = sample_sub[['ID']].copy()\n",
        "try:\n",
        "    test_df_base['date_str'] = test_df_base['ID'].str.split('_').str[0]\n",
        "    test_df_base['date'] = pd.to_datetime(test_df_base['date_str'], errors='coerce')\n",
        "    test_df_base['user_id'] = test_df_base['ID'].str.split('_', n=1).str[1]\n",
        "    test_df_base.dropna(subset=['date'], inplace=True)\n",
        "except Exception as e: raise ValueError(f\"Error parsing ID: {e}\")\n",
        "print(f\"[{time.time() - test_prep_start_time:.1f}s] Base test structure created.\")\n",
        "\n",
        "\n",
        "# --- 2. Merge Future Climate Data ---\n",
        "print(f\"[{time.time() - test_prep_start_time:.1f}s] Merging climate data...\")\n",
        "test_df = pd.merge(test_df_base, daily_climate, on='date', how='left')\n",
        "test_df.sort_values(by='date', inplace=True)\n",
        "test_df.ffill(inplace=True)\n",
        "test_df.bfill(inplace=True)\n",
        "climate_cols_in_test = [col for col in daily_climate.columns if col != 'date' and col in test_df.columns]\n",
        "print(f\"[{time.time() - test_prep_start_time:.1f}s] Climate data merged.\")\n",
        "\n",
        "\n",
        "# --- 3. Combine History for Feature Calculation ---\n",
        "print(f\"[{time.time() - test_prep_start_time:.1f}s] Combining history...\")\n",
        "max_lag = max((int(c.split('_')[-1]) for c in lag_cols_created), default=0)\n",
        "max_roll_window = max((int(c.split('_')[-2]) for c in rolling_cols_created), default=0)\n",
        "history_needed_days = max_lag + max_roll_window + 1\n",
        "min_test_date = test_df['date'].min()\n",
        "cutoff_date = min_test_date - pd.Timedelta(days=history_needed_days)\n",
        "print(f\"Need history back to {cutoff_date.date()}\")\n",
        "cols_to_keep_hist = ['user_id', 'date', 'daily_kwh']\n",
        "historical_data = df_train_full[df_train_full['date'] < min_test_date][cols_to_keep_hist].copy()\n",
        "test_users = test_df['user_id'].unique()\n",
        "historical_data = historical_data[historical_data['user_id'].isin(test_users)]\n",
        "historical_data = historical_data[historical_data['date'] >= cutoff_date]\n",
        "future_data_cols = ['user_id', 'date'] + climate_cols_in_test\n",
        "future_data = test_df[future_data_cols].copy()\n",
        "future_data['daily_kwh'] = np.nan\n",
        "combined_df = pd.concat([historical_data, future_data], ignore_index=True)\n",
        "combined_df = combined_df.sort_values(by=['user_id', 'date'])\n",
        "combined_df.drop_duplicates(subset=['user_id', 'date'], keep='last', inplace=True)\n",
        "print(f\"Combined data shape: {combined_df.shape}\")\n",
        "\n",
        "\n",
        "# --- 4. Calculate Lag Features ---\n",
        "print(f\"[{time.time() - test_prep_start_time:.1f}s] Calculating lag features...\")\n",
        "if lag_cols_created:\n",
        "    target_col_for_lags = 'daily_kwh'\n",
        "    lags_to_create = [int(c.split('_')[-1]) for c in lag_cols_created]\n",
        "    # Need to convert user_id to category in combined_df if not already\n",
        "    if combined_df['user_id'].dtype.name != 'category':\n",
        "        print(\"Converting combined_df user_id to category for groupby...\")\n",
        "        combined_df['user_id'] = combined_df['user_id'].astype('category')\n",
        "    for lag in lags_to_create:\n",
        "        col_name = f\"daily_kwh_lag_{lag}\"\n",
        "        combined_df[col_name] = combined_df.groupby('user_id', observed=True)[target_col_for_lags].shift(lag) # added observed=True\n",
        "    print(\"Lag calculation finished.\")\n",
        "\n",
        "\n",
        "# --- 5. Calculate Rolling Window Features ---\n",
        "#print(f\"\\n[{time.time() - test_prep_start_time:.1f}s] Calculating rolling features...\")\n",
        "#if rolling_cols_created:\n",
        "#    target_col_for_rolling = 'daily_kwh'\n",
        "#    windows = sorted(list(set(int(c.split('_')[-2]) for c in rolling_cols_created)))\n",
        "#   stats = sorted(list(set(c.split('_')[-1] for c in rolling_cols_created)))\n",
        "#    print(f\"Using windows: {windows}, stats: {stats}\")\n",
        "#    # Ensure user_id is category for groupby\n",
        "#    if combined_df['user_id'].dtype.name != 'category':\n",
        "#        print(\"Converting combined_df user_id to category for groupby...\")\n",
        "#        combined_df['user_id'] = combined_df['user_id'].astype('category')\n",
        "#    grouped = combined_df.groupby('user_id', observed=True)[target_col_for_rolling] # added observed=True\n",
        "#    for window in windows:\n",
        "#        shifted_grouped = grouped.shift(1)\n",
        "#        rolling_object = shifted_grouped.rolling(window=window, min_periods=1)\n",
        "#        for stat in stats:\n",
        "#             col_name = f'daily_kwh_roll_{window}_{stat}'\n",
        "#             if col_name in rolling_cols_created:\n",
        "#                  combined_df[col_name] = rolling_object.agg(stat)\n",
        "#    print(\"Rolling window calculation finished.\")\n",
        "\n",
        "\n",
        "# --- 6. Create Date Features ---\n",
        "print(f\"\\n[{time.time() - test_prep_start_time:.1f}s] Creating date features...\")\n",
        "combined_df = create_date_features(combined_df, 'date')\n",
        "print(f\"Date features created.\")\n",
        "\n",
        "\n",
        "# --- 7. Filter Back to Required Test Dates ---\n",
        "print(f\"\\n[{time.time() - test_prep_start_time:.1f}s] Filtering back to required test dates...\")\n",
        "test_df_final = pd.merge(test_df_base[['ID', 'user_id', 'date']], combined_df, on=['user_id', 'date'], how='left')\n",
        "print(f\"Filtered back to test set shape: {test_df_final.shape}\")\n",
        "if len(test_df_final) != len(sample_sub): print(f\"WARNING: Row count mismatch! Got {len(test_df_final)}\")\n",
        "\n",
        "\n",
        "# --- 8. Final Checks and Feature Alignment ---\n",
        "print(f\"\\n[{time.time() - test_prep_start_time:.1f}s] Final checks and feature alignment...\")\n",
        "\n",
        "# --- Convert user_id to category in test_df_final --- <<<< NEW STEP >>>>\n",
        "if 'user_id' in test_df_final.columns:\n",
        "    print(\"Converting user_id in test_df_final to category dtype...\")\n",
        "    test_df_final['user_id'] = test_df_final['user_id'].astype('category')\n",
        "else:\n",
        "    print(\"Warning: user_id column not found in test_df_final before dtype conversion.\")\n",
        "\n",
        "# Check feature availability\n",
        "features_in_test = [f for f in features if f in test_df_final.columns]\n",
        "missing_features_in_test = [f for f in features if f not in test_df_final.columns]\n",
        "if missing_features_in_test:\n",
        "    print(f\"--- ERROR: Features missing from final test df: {missing_features_in_test} ---\")\n",
        "    raise ValueError(\"Mismatch between training features and test_df columns.\")\n",
        "\n",
        "# Handle NaNs (excluding categorical user_id)\n",
        "print(f\"Handling NaNs in final test features (filling with 0)...\")\n",
        "numeric_features_in_test = [f for f in features_in_test if f != 'user_id']\n",
        "test_df_final[numeric_features_in_test] = test_df_final[numeric_features_in_test].fillna(0)\n",
        "\n",
        "# Define X_test using only the available features used in training\n",
        "X_test = test_df_final[features_in_test]\n",
        "if X_test.isnull().any().any():\n",
        "    print(\"--- FATAL ERROR: NaNs found in X_test before prediction! ---\")\n",
        "    raise ValueError(\"NaNs detected in X_test.\")\n",
        "else:\n",
        "    print(\"[ OK ] Final test features (X_test) prepared. Shape: {X_test.shape}\")\n",
        "    # Ensure user_id is category in X_test\n",
        "    if X_test['user_id'].dtype.name != 'category': print(\"Warning: X_test user_id is not category!\")\n",
        "\n",
        "\n",
        "# --- 9. Predict on Test Set using FINAL MODEL ---\n",
        "print(f\"\\n[{time.time() - test_prep_start_time:.1f}s] Predicting using final_model...\")\n",
        "model_features = final_model.feature_name_\n",
        "predict_features = [f for f in model_features if f in X_test.columns]\n",
        "if len(predict_features) != len(model_features):\n",
        "    print(f\"Warning: Feature mismatch! Model trained on {len(model_features)}, predicting on {len(predict_features)}\")\n",
        "    missing_for_pred = [f for f in model_features if f not in X_test.columns]\n",
        "    print(f\"   Missing features for prediction: {missing_for_pred}\")\n",
        "    X_test_reordered = X_test[predict_features]\n",
        "else:\n",
        "    # Ensure X_test columns are in the same order as the model expects\n",
        "    # This is important now that user_id is included\n",
        "    print(\"Reordering X_test columns to match model training order.\")\n",
        "    X_test_reordered = X_test[model_features]\n",
        "\n",
        "test_predictions = final_model.predict(X_test_reordered)\n",
        "test_predictions_non_negative = np.maximum(0, test_predictions)\n",
        "if np.sum(test_predictions < 0) > 0: print(\"Note: Negative predictions clipped.\")\n",
        "\n",
        "print(\"Prediction on test set complete.\")\n",
        "test_prep_total_time = time.time() - test_prep_start_time\n",
        "print(f\"\\n[{test_prep_total_time:.1f}s] Cell 16 processing finished.\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "f0b01330",
      "metadata": {
        "id": "f0b01330"
      },
      "source": [
        "## 9. Generate Submission File\n",
        "\n",
        "Create the final submission file in the format required by Zindi: a CSV file with two columns, `ID` and `kwh`. The `ID` column must match the `SampleSubmission.csv`."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 68,
      "id": "4dba38c1",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "4dba38c1",
        "outputId": "a8b2894d-29e6-4838-88c4-7990c0f55597"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Generating submission file...\n",
            "\n",
            "--- Submission File Head ---\n",
            "                                          ID       kwh\n",
            "0  2024-09-24_consumer_device_12_data_user_1  0.016091\n",
            "1  2024-09-25_consumer_device_12_data_user_1  0.015472\n",
            "2  2024-09-26_consumer_device_12_data_user_1  0.015472\n",
            "3  2024-09-27_consumer_device_12_data_user_1  0.015465\n",
            "4  2024-09-28_consumer_device_12_data_user_1  0.016091\n",
            "\n",
            "Submission file saved successfully as: submission_v6_lags_roll_userid.csv\n",
            "File shape: (6014, 2)\n",
            "Row count matches SampleSubmission.csv.\n"
          ]
        }
      ],
      "source": [
        "# Cell 18: Generate Submission File (Revised Filename)\n",
        "\n",
        "print(\"Generating submission file...\")\n",
        "\n",
        "submission_df = pd.DataFrame({'ID': test_df_final['ID'], 'kwh': test_predictions_non_negative})\n",
        "\n",
        "# Define the submission filename - V4 with Lags, Rolling, UserID\n",
        "submission_filename = 'submission_v6_lags_roll_userid.csv' # <<<--- CHANGED FILENAME ---<<<\n",
        "\n",
        "submission_df.to_csv(submission_filename, index=False)\n",
        "\n",
        "print(\"\\n--- Submission File Head ---\")\n",
        "print(submission_df.head())\n",
        "print(f\"\\nSubmission file saved successfully as: {submission_filename}\")\n",
        "print(f\"File shape: {submission_df.shape}\")\n",
        "\n",
        "if len(submission_df) == len(sample_sub): print(\"Row count matches SampleSubmission.csv.\")\n",
        "else: print(f\"WARNING: Row count mismatch! Submission: {len(submission_df)}, SampleSub: {len(sample_sub)}.\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5cc93c28",
      "metadata": {
        "id": "5cc93c28"
      },
      "source": [
        "--- End of Baseline Notebook ---\n",
        "\n",
        "Next steps:\n",
        "- Submit the generated CSV to Zindi.\n",
        "- Analyze the results (local RMSE vs Zindi score).\n",
        "- Improve the model by:\n",
        "    - Adding more features (lags, rolling windows, user features).\n",
        "    - Tuning hyperparameters (e.g., using Optuna).\n",
        "    - Trying different models (XGBoost, CatBoost).\n",
        "    - Implementing more robust validation (Time Series Cross-Validation).\n",
        "    - Ensembling models."
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# TEMPORARY CELL FOR GIT OPERATIONS - DELETE OUTPUT/CELL AFTER USE\n",
        "\n",
        "import os\n",
        "\n",
        "# --- 1. Clone (only if needed / runtime restarted) ---\n",
        "# Check if repo exists, clone only if necessary\n",
        "repo_name = \"zindi-mhp-energy-prediction-2025\"\n",
        "repo_path = os.path.join('/content', repo_name)\n",
        "\n",
        "if not os.path.exists(repo_path):\n",
        "    print(f\"Repository '{repo_name}' not found. Cloning...\")\n",
        "    # Replace with your PAT!\n",
        "    !git clone https://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@github.com/daveAnalyst/zindi-mhp-energy-prediction-2025.git\n",
        "    if not os.path.exists(repo_path): # Check again after clone attempt\n",
        "         print(\"--- ERROR: Clone failed! Cannot proceed with Git operations. ---\")\n",
        "         # Stop here if clone failed\n",
        "         raise RuntimeError(\"Git clone failed\")\n",
        "else:\n",
        "    print(f\"Repository '{repo_name}' already exists.\")\n",
        "\n",
        "# --- 2. Change Directory ---\n",
        "current_dir = os.getcwd()\n",
        "if os.path.basename(current_dir) != repo_name:\n",
        "    print(f\"Changing directory to: {repo_path}\")\n",
        "    os.chdir(repo_path)\n",
        "print(f\"Current directory: {os.getcwd()}\")\n",
        "\n",
        "\n",
        "# --- 3. Configure Git User (Important for commit history) ---\n",
        "# Replace with your actual email and name used on GitHub\n",
        "!git config --global user.email \"daveAnalyst@example.com\" #<-- YOUR GITHUB EMAIL\n",
        "!git config --global user.name \"DaveAnalyst\" #<-- YOUR GITHUB NAME/USERNAME\n",
        "\n",
        "\n",
        "# --- 4. Check Status (Optional but recommended) ---\n",
        "print(\"\\n--- Git Status ---\")\n",
        "!git status\n",
        "\n",
        "\n",
        "# --- 5. Add Files ---\n",
        "# Add the main notebook and any generated submission files etc.\n",
        "print(\"\\n--- Adding files ---\")\n",
        "!git add zindi_mhp_dev.ipynb submission_*.csv requirements.txt # Adjust as needed\n",
        "# Or use !git add . cautiously\n",
        "\n",
        "\n",
        "# --- 6. Commit ---\n",
        "commit_message = \"Update from Colab: Added lag/rolling features, generated submission v2\" #<-- CHANGE COMMIT MESSAGE\n",
        "print(f\"\\n--- Committing with message: '{commit_message}' ---\")\n",
        "!git commit -m \"{commit_message}\"\n",
        "\n",
        "\n",
        "# --- 7. Push ---\n",
        "print(\"\\n--- Pushing to GitHub ---\")\n",
        "# This assumes the clone URL included the PAT or you have other auth set up\n",
        "# If the clone URL didn't have PAT, this might prompt for username/PAT password\n",
        "!git push origin main # Or your default branch name\n",
        "\n",
        "\n",
        "print(\"\\n--- Git operations complete ---\")"
      ],
      "metadata": {
        "id": "hajGHazbqwMU",
        "outputId": "4f886122-ff3a-461a-8502-8d7b9a964796",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "id": "hajGHazbqwMU",
      "execution_count": 69,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Repository 'zindi-mhp-energy-prediction-2025' not found. Cloning...\n",
            "Cloning into 'zindi-mhp-energy-prediction-2025'...\n",
            "remote: Enumerating objects: 10, done.\u001b[K\n",
            "remote: Counting objects: 100% (10/10), done.\u001b[K\n",
            "remote: Compressing objects: 100% (10/10), done.\u001b[K\n",
            "remote: Total 10 (delta 3), reused 4 (delta 0), pack-reused 0 (from 0)\u001b[K\n",
            "Receiving objects: 100% (10/10), 61.30 KiB | 1.46 MiB/s, done.\n",
            "Resolving deltas: 100% (3/3), done.\n",
            "Changing directory to: /content/zindi-mhp-energy-prediction-2025\n",
            "Current directory: /content/zindi-mhp-energy-prediction-2025\n",
            "\n",
            "--- Git Status ---\n",
            "On branch master\n",
            "Your branch is up to date with 'origin/master'.\n",
            "\n",
            "nothing to commit, working tree clean\n",
            "\n",
            "--- Adding files ---\n",
            "fatal: pathspec 'submission_*.csv' did not match any files\n",
            "\n",
            "--- Committing with message: 'Update from Colab: Added lag/rolling features, generated submission v2' ---\n",
            "On branch master\n",
            "Your branch is up to date with 'origin/master'.\n",
            "\n",
            "nothing to commit, working tree clean\n",
            "\n",
            "--- Pushing to GitHub ---\n",
            "error: src refspec main does not match any\n",
            "\u001b[31merror: failed to push some refs to 'https://github.com/daveAnalyst/zindi-mhp-energy-prediction-2025.git'\n",
            "\u001b[m\n",
            "--- Git operations complete ---\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import os\n",
        "\n",
        "repo_name = \"zindi-mhp-energy-prediction-2025\" # Make sure this matches your repo folder name\n",
        "\n",
        "# Check if we are already in the repo directory, if not, change into it\n",
        "current_dir = os.getcwd()\n",
        "print(f\"Current directory before check: {current_dir}\")\n",
        "if os.path.basename(current_dir) != repo_name:\n",
        "    repo_path = os.path.join('/content', repo_name) # Assuming it was cloned into /content\n",
        "    if os.path.exists(repo_path):\n",
        "        print(f\"Changing directory to: {repo_path}\")\n",
        "        os.chdir(repo_path)\n",
        "    else:\n",
        "        print(f\"ERROR: Repository path '{repo_path}' does not exist. Did the clone succeed?\")\n",
        "        # You might need to re-run the !git clone cell if the folder is missing\n",
        "\n",
        "# Now verify the directory again and run git status\n",
        "print(f\"Current directory now: {os.getcwd()}\")\n",
        "print(\"\\n--- Git Status ---\")\n",
        "!git status"
      ],
      "metadata": {
        "id": "0v2ByoCJqxfx",
        "outputId": "a9edb49b-b8fa-4f21-d7b2-c6fff7b61537",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "id": "0v2ByoCJqxfx",
      "execution_count": 16,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Current directory before check: /content\n",
            "ERROR: Repository path '/content/zindi-mhp-energy-prediction-2025' does not exist. Did the clone succeed?\n",
            "Current directory now: /content\n",
            "\n",
            "--- Git Status ---\n",
            "fatal: not a git repository (or any of the parent directories): .git\n"
          ]
        }
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "zindi_mhp_venv",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.11.9"
    },
    "colab": {
      "provenance": [],
      "include_colab_link": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}